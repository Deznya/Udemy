'use strict' // Это инструкция JS более пристально наблюдать за переменными и не только.
 // Достаточно добавить первой строкой в любой код, допустим над функцией которая что-то делает.


// Колбэки и функции высшего порядка. Фундаментальный JavaScript
// Ссылка на ролик https://youtu.be/ab0a8ZbCNMY

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения const c = a + b
    // Функции function myFn(a, b) {}
    // Обьекты {}

//////////////////////////////  Переменные!!!  //////////////////////////////

// 1) Все переменные обьявлять перед их использованием.
// 2) Стараться использовать const везде, где это возможно.

// Имена переменных:

// 1) PascalCase // Типы и Классы
// 2) DB_PASSWORD // Значения известны до запуска приложения и не меняются.
// 3) camelCase // Все остальные переменные.

const j = 10 // Переменная j типа число.
const h = 10+ 5 // Выражение.


//////////////////////////////  Примитивные типы!!!  //////////////////////////////

// Тип string(строка)
// boolean(логический тип)
// number(число)
// null
// undefined (неопределенно)
// symbol (символ)

const g = 15 // Примитив
const k = 'Vlad' // Примитив

//////////////////////////////  Ссылочный Тип!!!  //////////////////////////////

// object(обьект)

//////////////////////////////  Обьекты!!!  //////////////////////////////


// Если какй-то свойство содержит функцию как значение, такое свойство называется метод!

// Обьект это набор свойст, имя: значение.
// Переменная в которую мы присваиваем обьект, содержит только ссылку на обьект а сам обьект находится в другом месте памяти.


// ПОРЯДОК СВОЙСТВ НЕ ИМЕЕТ ЗНАЧЕНИЯ!!!
const myCity1 = {
    city: 'New York',
    popular: true,
    country: 'USA'
} // свойсто city:  значение 'USA'

// ПОЛУЧАЕМ ДОСТУП К ОБЬЕКТУ!!!

console.log(myCity1.city) // New York
// Точечная запись
console.log(myCity1.popular) // true
// Точечная запись

//////////////////////////////  ИЗМЕНЕНИЕ ЗНАЧЕНИЙ СВОЙСТВА ОБЬЕКТА!  //////////////////////////////

const myCity ={
    city: 'New York'
}

myCity.city = 'Las Vegas'
// Изменяем в свойстве city значение 'New York' НА 'Las Vegas'.

console.log(myCity) // { city: 'Las Vegas' }


//////////////////////////////  ИЗМЕНЕНИЕ ЗНАЧЕНИЙ СВОЙСТВА ОБЬЕКТА!  //////////////////////////////

// Переменная myCity ТИПА ОБЬЕКТ.
const myCity ={
    city: 'New York'
}
// В const находится ССЫЛКА на обьект myCity, поэтому мы можем менять его свойства и значения.
// Происходит мутация данного обьекта. Нужно делать копию обьекта и мутировать КОПИЮ обьекта а не ОРИГИНАЛ!

myCity.popular = true
// Добавили с помощью точечной записи в обьект свойство popular:  значение true.

console.log(myCity)
// { city: 'New York', popular: true}

myCity.country = 'USA'
// Добавили с помощью точечной записи в обьект свойство country:  значение 'USA'.

console.log(myCity)
// { city: 'New York', popular: true, country: 'USA' }



//////////////////////////////  УДАЛЕНИЕ СВОЙСТВ ОБЬЕКТА оператор delete!  //////////////////////////////

delete myCity.country
// Удалили свойство country

console.log(myCity)


//////////////////////////////  ДОСТУП К ЗНАЧЕНИЮ СВОЙСТВА С ИСПОЛЬЗОВАНИЕМ СКОБОК []  //////////////////////////////


const myCity ={
    city: 'New York'
}

myCity['popular'] = true
// Добавили в обьектс помощью [] свойство popular:  значение true.

console.log(myCity)
// { city: 'New York', popular: true }


const countryPropertyName = 'country'
// Поместили в переменную свойство 'country' для обьекта.

myCity[countryPropertyName] = 'USA'
// Присвоили к свойству 'country' значение 'USA'
// Добавили country: 'USA' свойство хранится в переменной countryPropertyName.
// JS перед созданием свойства посмотрит в переменную countryPropertyName, после чего создаст свойство которое хранится в переменной countryPropertyName, далее присвоили значение свойства = 'USA'.
// Есди нужно создать свойство из перменной используем скобки [] в остальных случаях используем точечную запись.

console.log(myCity)
// { city: 'New York', popular: true, country: 'USA' }

// ОТЛИЧИЕ СКОБОЧНОЙ ЗАПИСИ ОТ ТОЧЕЧНОЙ, 
// В ТО ЧТО В CКОБОЧНОЙ ЗАПИСИ [] МОЖНО ИСПОЛЬЗОВАТЬ ЛЮБОЕ ВЫРАЖЕНИЕ!

// Пример 2

const myCity ={
    name: 'Vlad',
    age: 25
}

const myCountry = 'city'

console.log(myCity)
// { name: 'Vlad', age: 15 }


myCity[myCountry] = 'USA'

console.log(myCity)
// { name: 'Vlad', age: 15, city: 'USA' }


 //////////////////////////////  В JS МОГУТ БЫТЬ ВЛОЖЕННЫЕ СВОЙСТВА КОТОРЫЕ СОДЕРЖАТ ВЛОЖЕННЫЕ ОБЬЕКТЫ!  //////////////////////////////


 const myCity = {
    city: 'New York',
    info: {
        isPopular: true,
        country: 'USA'
    }
 }

 console.log(myCity.info.isPopular) // true 
// Точечная запись, переходим во вложенный обьект и выводим значение свойства isPopular.


delete myCity.info.isPopular
 // Получаем доступ в вложенный обьекта info и удаляем его с помощью оператора delete. 
 // Можно через скобочную [] запись delete myCity.info['isPopular']
 // Скобочную запись используем когда в скобках должно быть выражение, допустим название переменной.


 console.log(myCity)
 // { city: 'New York', info: { country: 'USA' } }


 //////////////////////////////  ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ ПРИ ФОРМИРОВАНИИ ОБЪЕКТА! //////////////////////////////

 const name = 'Vlad'
 const postsQty = 23
 // Используем название перменных как выражение для свойст обьекта.

 const userProfile = { 
    name: name,
    postsQty: postsQty,
    hasSignedAgreement: false
 }

// Сначала JS получит результат того или иного свойства а после этого этот результат присвоится тому или иному свойству обьекта.

// Сокращенные свойства рекомендуется размещать в начале обьекта, чтобы было ясно где переменные в которых хранятся значения.

// const userProfile = { 
//     name,
//     postsQty,
//     hasSignedAgreement: false
//  }
 
// Сокращенный формат записи когда название переменной где находится значение свойства совподвет с название свойства!

// Обычно часть значений уже известно до формирования объекта, такие значения можно поместить в переменные. Допустим переменная password где будет находится пароль.


////////////////////////////// ГЛОБАЛЬНЫЕ ОБЪЕКТЫ! //////////////////////////////


console // Браузер глобальный обьект.

window.console // Hrome глобальный обьект.

global.console // Node.JS глобальный обьект.

globalThis // Унифицированный глобальный обьект.


// СВОЙСТВО ГЛОБАЛЬНЫХ ОБЬЕКТОВ 

window.console

global.console

console.log('Hello')

window.console.log('Hello')

global.console.log('Hello')
// Одно и тоже!



//////////////////////////////  МЕТОД - СВОЙСТВО ОБЪЕКТА ЗНАЧЕНИЕ КОТОРОГО - ФУНКЦИЯ! //////////////////////////////

// Методы - свойства обьекта, которые содержат функции.

const myCity = {
    city: 'New York',
    cityGreeting: function () {
        console.log('Greetings!!!')
    }
    
}
// В данном примере cityGreeting это метод. Вот city это просто свойство так как его значение не является функцией!!!
myCity.cityGreeting()
// Вызов МЕТОДА!

// Сокращенный формат записи без : и слова function!

const myCity = {
    city: 'New York',
    cityGreeting() { // Сокращенный формат записи.
        console.log('Greetings!!!')
    }
    
}


myCity.cityGreeting()
// Вызов МЕТОДА!


////////////////////////////// ЕСЛИ СРАВНИТЬ МЕТОДЫ VS СВОЙСТВА ОБЬЕКТОВ! //////////////////////////////

// Отличия СВЙОСТВА НЕ сожержат функции как значения а МЕТОДЫ СОДЕРЖАТ!!!
// шаблон обьекта свойство: значение

myCity.city
// Доступ к свойству

myCity.cityGreeting()
// Вызов метода



////////////////////////////// JSON! //////////////////////////////


// Есть 2 метода, для конвертиртации JSON в JS обьект и наоборот JS обьект в JSON.


JSON.parse()
// Конвертирует (парсим) JASON в JS Обьект.

JSON.stringify()
// Конвертирует JS Обьект в JASON.


const post = {
    title: 'My post',
    likesQty: 5
}
// Порядок свойств не имеет значения.

console.log(post)
// { title: 'My post', likesQty: 5 }

const postStringify = JSON.stringify(post)
// Конвертирует JS Обьект в СТРОКУ JASON.

console.log(postStringify)
// Получили СТРОКУ JSON '{"title":"My post","likesQty":5}'

const postParse = JSON.parse(postStringify)
// Конвертирует СТРОКУ JASON в JS Обьект.

console.log(postParse)
// Получили ОБЬЕКТ JS { title: 'My post', likesQty: 5 }

// JSON ЭТО ФОРМАТ ПЕРЕДАЧИ ДАННЫХ В ИНТЕРНЕТЕ!!!


////////////////////////////// МУТАЦИИ В JS! //////////////////////////////


// ЗНАЧЕНИЯ ПРИМИТИВНЫХ ТИПОВ!!! ЭТО ОЧЕНЬ ВАЖНО!!! ОСНОВЫ ОСНОВ!

// Крпирование по ЗНАЧЕНИЮ!
// ЗНАЧЕНИЕ ПРИМИТИВНЫХ ТИПОВ СОХРАНЯЕТСЯ НЕПОСРЕДСТВЕННО В САМИХ ПЕРЕМЕННЫХ!

const a = 10
// Переменная a ТИПА число ПРИМИТИВ!!!!

let b = a
// Обьявили новую переменную let b И КРАИРУЕМ a В b

b = 30
// 

console.log(a)
// 10

console.log(b)
// 30

////////////////////////////// ЗНАЧЕНИЯ ССЫЛОЧНОГО ТИПА!!! //////////////////////////////

const person = {
    name: 'Bob',
    age: 21
}

person.age = 22
// Изменили в свойстве age значение С 21 НА 22.
// Мутация Обьекта. Нужно делать копию ОБЪЕКТА и после его изменять.
person.isAdult = true
// Добавили свойство isAdult: и его значение true.
// Мутация Обьекта. Нужно делать копию ОБЪЕКТА и после его изменять.

console.log(person.age) // 22
console.log(person.isAdult) // true


// МУТИРОВАНИЕ ОБЬЕКТА ЧЕРЕЗ КОПИЮ.
const person = {
    name: 'Bob',
    age: 21
}


const person2 = person
// Крпируем ССЫЛКУ на обьект в памяти.
// То есть мы не обьект person скопировали в переменную person2 а ССЫЛКУ на один обьект в памяти!!!
// Теперь мы можем менять даннй обьект как через переменную person так и person2.


person2.age = 26
// Изменили в свойстве age значение НА 26.
person2.isAdult = true
// Добавили свойство isAdult: и его значение true.

// Мутируем обьект через ССЫЛКУ, которая хранится в переменной person2.
// То есть есть 1 обьект, ССЫЛКА на него находится в двух переменных person и person2.
// ЭТО ПРОИСХОДИТ И ЗА ТОГО ЧТО МЫ КОПИРУЕМ ТОЛЬКО ССЫЛКУ НА ОБЬЕКАТ А НЕ САМ ОБЬЕКТ!!!

console.log(person.age) // 26
console.log(person.isAdult) // true

// Всегда нужно помнить что ПРИМИТИВНЫЙ ТИП КОПИРУЕТСЯ ПО ЗНАЧЕНИЮ А ССЫЛОЧНЫЙ ТИП КОПИРУЕТСЯ ПО ССЫЛКЕ!!!





////////////////////////////// КАК ИЗБЕЖАТЬ МУТАЦИИ ОБЪЕКТОВ!!! //////////////////////////////

// Что делать если мы не хотим чтобы ОБЬЕКТ МЕНЯЛСЯ когда мы создаем КОПИЮ такого ОБЬЕКТА.

// Вариант номер 1

const person = {
    name: 'Bob',
    age: 25
}

const person2 = Object.assign({}, person)
// Object это и ТИП и КЛАСС потому с большой буквы O
// С помощью метода assign можем создать КОПИЮ нового обьекта на базе старого.
// То есть не ссылку на обьект а полностью новый обьект, МЕТОД assign создат новый обьект и запишет в него свойства обьекта person.
// Где в параметрах {} новый обьект С старого person.

person2.age = 26

console.log(person2.age) // 26
console.log(person.age) // 25

// Но если у обьекта person есть вложенные обьекты ТО ССЫЛКИ НА ЭТИ ВЛОЖЕННЫЕ ОБЬЕКТЫ СОХРАНЯЮТСЯ!!!
// То есть если есть свойство значение которого ОБЬЕКТ.

// Можно использовать Object.assign() где нет вложенных обьектов.



// Вариант номер 2


const person = {
    name: 'Bob',
    age: 25
}

const person2 = {...person}
// Три точки ... оператор СПРЕД (распыление)
// Берется обьект person и разделяется на свойства, в данном примере на name и age.
// Мы разделили старый обьект на свойства с помощью СПРЕД ... и сразу собрали эти свойства в НОВЫЙ обьект!
// person2 ЭТО НОВАЯ ССЫЛКА КОТОРАЯ ССЫЛАЕТСЯ НА НОВЫЙ ОБЬЕКТ!


person2.name = 'Alice'
// Меняем свойства НОГОВО обьекта person2.

console.log(person2.name) // Выводим свойство НОВОСОДАННОГО обьекта Alice
console.log(person.name) // Выводим свойство оригинального обьекта Bob


// Здесь как и в ВАРИАНТЕ 1 если у обьекта person есть вложенные обьекты ТО ССЫЛКИ НА ЭТИ ВЛОЖЕННЫЕ ОБЬЕКТЫ СОХРАНЯЮТСЯ!!!
// То есть меняя вложенные обьекты в распыленном обьекте спредом, ОНИ ПОМЕНЯЮТСЯ И В ОРИГИНАЛЬНОМ ОБЬЕКТЕ!!!
// Ссылки вложенных обьектов сохрянятся на ОРИГИНАЛЬНЫЙ обьект.

// Спред и Object.assign() МОЖНО ИСПОЛЬЗОВАТЬ ТОЛЬКО ЕСЛИ НЕТ ВЛОЖЕННЫХ ОБЬЕКТОВ!!!


////////////////////////////// ИЗБЕЖАТЬ МУТАЦИИ ОБЪЕКТОВ на 100% использую JSON!!! //////////////////////////////


// Вариант 3


const person = {
    name: 'Bob',
    age: 25
}

const person2 = JSON.parse(JSON.stringify(person))

// 1) Конвентируем обьект person в строку JSON.stringify(person) (Код работает как матрёшка, ИЗНУТРИ НАРУЖУ.)
// 2) На результате метода JSON.stringify(person) получили строку JSON.
// 3) Переадем строку JSON как аргемент в метод JSON.parse()
// 4) С помощью метода JSON.parse() мы обратно конвентируем строку JSON в ОБЬЕКТ JS.
// Итог, происходит двойная конвертация обьекта в строку JSON и обратно строка JSON в обьект!
// Мы получим новый обьект и в этом новом обьекте мы можем менять любые свойства, даже в вложенных обьектах.
// Оригинальный Обьект с которого мы делали конвертицию затронут не будет!
// Ссылки на вложенные обьекты если такие есть, НЕ СОХРАНЯЮТСЯ!!! Получили то что хотели.

person2.name = 'Alice'

console.log(person2.name) // Alice
console.log(person.name) // Bob



////////////////////////////// ФУНКЦИИ!!! //////////////////////////////


// 1. Функции - параметр это то что в скобках функции (локальная переменная внутри функции. Допустим a и b!
//     2. Аргумент в функции это значение для параметра во время вызова функции!
//     3. Если нужно что-то найти это значит перебрать массив, это цикл for или for of, forEach, map.
//     4. Если нужна что-то сравнить это if. 
//     5. Метод это функция объекта.
//     6. Ключевое слово This если есть вызов объект точка что-то это значит что слева , пример. user.xxxxx то This будет ссылаться на объект user! This ссылается время вызова! Не в момент объявления! Если This вызывает как метод объекта, This всегда ссылается на этот объект user.xxxxx! Если This вырывается без объекта foo(); тогда будет Undefined!
    

// Функция - это блок кода котрый можно выполнять многократно.

// Пример
let l = 5
let p = 3

c = l + p
// Одинаковые блоки кода!

console.log(c) // 8

let n = 10
let m = 5

c = n + m
// Одинаковые блоки кода!

console.log(c) // 8

// Очень рекомендуется избегать повторений блоков кода!

// На помощь приходят ФУНКЦИИ!

// Вариант 1
    function sum(a, b) {
    console.log( a + b ) 
    }


sum(10, 15) // 25

sum(10, 25) // 35

// Вариант 2
    function sumA(a, b) {
       const c = a + b 
       console.log(c) 
    }

a = 8
b = 12

    sumA(a, b) // 

    // Функция может быть...

    // 1) ...именованной
    // 2) ...присвоено переменной
    // 3) ...анонимной (без имени)
    // 4) ...аргументом при вызове другой функции (Callback функции)
    // 5) ...значением свойства (метода) обьекта. (Метод это свойство обьекта значение которого функция)

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения
    // Функции
    // Обьекты



////////////////////////////// ФУНКЦИЯ - ЭТО ОБЬЕКТ!!! //////////////////////////////


function myFn(a, b) { // (a, b) параметры функции, это переменные внутри функции а значение их определяются в момент ВЫЗОВА ФУНКЦИИ myFn(10, 5)!!!
let c
a = a + 1
c = a + b
return c // Вернет результат который равен переменной С
// После инструкция return Функция прекращает дальнейшие инструкции!!!
// Если после return есть каий-то операции они не будет выполнены!!!
// Если return ТО функция возвращает результат и заканчивает свою работу.
// Если использовали return ФУНКЦИЯ ВОЗВРАЩАЕТ РЕЗУЛЬТАТ И ЗАКАНЧИВАЕТ СВОЮ РАБОТУ!!!!
}

const res = myFn(15, 5) // Это (15, 5) аргументы!

console.log(res)

console.log(myFn.name) // myFn ФУНКЦИЯ - ЭТО ОБЬЕКТ.



////////////////////////////// ФУНКЦИЯ ВОЗВРАЩАЕТ UNDEFINED ЕСЛИ НЕТ ИНСТРУКЦИИ return ВАЖНО !!! //////////////////////////////


// Если мы говорим АРГУМЕНТЫ функции имеем ввиду ВЫЗОВ ФУНКЦИИ.
// // Если мы говорим ПАРАМЕТРЫ функции имеем ввиду ОБЬВЛЕНИЕ ФУНКЦИИ.

// Резюмируя 

// 1) Обьявили функцию в результате которой создасться переменная myFn.
// 2) Ее значение будет функция!
// 3) myFn(15, 5) вызыыввем функцию и в вызове указываем 2 аргумента 15 которые присвоятся в параметр a И 5 который присвоится в параметр b  function myFn(a, b)
// Функция возвращает значение!



function myFn(a, b) { 
    a = a + 1
    c = a + b
    return c 
    }    // ЕСЛИ НЕТ ИНСТРУКЦИИ return ФУНКЦИЯ ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ТИПА UNDEFINED

    myFn(10, 3) // 14

// Что происходит внутри функции при ее вызове!

// 1) Параметрам "a" и "b" писваиваются значения 10 и 3
// 2) Обьявляется переменная "c"
// 3) Значение "a" увеличивается на 1
// 4) Сумма значений "a" и "b" присваивается "c"
// 5) Возвращает значение "c"

function myFn() {} // Самая короткая функция.

myFn() // undefined



////////////////////////////// ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ !!! //////////////////////////////

const personOne1 = {
    name: 'Bob',
    age: 21
}

function increasePersonAge(person) {
    person.age +=1
    return person
}
// Внутри ФУНКЦИИ мутация ВНЕШНЕГО обьекта. Так делать НЕ РЕКОМЕНДУЕТСЯ!!!
// В параметр функции person передаем как аргумент обьект personOne.
// После переходим в person.age где значение 21 с помощью +=1 добавлем 1 получаем 22.

increasePersonAge(personOne1)
// Вызов функции increasePersonAge с передачей как аргумент обьект  personOne.
console.log(personOne1.age)

// Мы по ссылке которая находится в переменной в ОРИГИНАЛЬНОМ ОБЬЕКТЕ поменяли значение age: 21 на age: 22.



////////////////////////////// ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МУТИРОВАТЬ ВНЕШНИЕ ОБЪЕКТЫ!!! //////////////////////////////


// То есть мы не передаем ОРИНИНАЛЬНЫЙ ОБЬЕКТ как аргумент в ФУНКЦИЮ.
// Мы можем создать копию обьекта внутри функии!




const personOne = {
    name: 'Bob',
    age: 21
}

function increasePersonAge(person) {
    const updatePerson = Object.assign({}, person) // Создали НОВЫЙ ОБЬЕКТ и присвоили в переменную updatePers ОБЬЕКТ на БАЗЕ СТАРОГО personOne.
    updatePerson.age += 1 // К новому обьекту pdatePerson в свойство age добавили значение 1 на выходе получили age: 22
    return updatePerson // Возвращаем новый ОБЬЕКТ updatePerson.
}

const updatePersonOne = increasePersonAge(personOne) // Вызов ФУНКЦИИ 
console.log(personOne.age) // 21
console.log(updatePersonOne.age) // 22

// Вывод мы передаем ОБЪЕКТ в ФУНКЦИЮ не изменяя оригинальный ОБЪЕКТ.
// Чтобы не было мутации оригинального обьекта!!! Это важно!
// На выходе personOne НЕ ИЗМЕНИТСЯ, мы будем менять КОПИЮ такого ОБЬЕКТА.

// ФУНКЦИИ НЕ ДОЛЖНЫ МЕНЯТЬ ВНЕШНИЕ ПЕРЕМЕННЫЕ ОНИ ДОЛЖНЫ РАБОТАТЬ С СВОИМИ ВНУТРЕННИМИ ПЕРЕМЕННЫМИ!!!



//////////////////////////////  КОЛБЕК ФУНКЦИИ ВАЖНО!!!  //////////////////////////////



// Колбэки и функции высшего порядка. Фундаментальный JavaScript
// Ссылка на ролик https://youtu.be/ab0a8ZbCNMY

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения const c = a + b
    // Функции function myFn(a, b) {}
    // Обьекты {}

    //Пример

    // Функция 1
    function anotherFunction() {
        // Действия... 
        // Функция которую мы положим как аргумент в параметр Функции fnWithCallback.
        // Она же КОЛБЕК ФУНКЦИЯ!!!
        // Данная КОЛБЕК ФУНКЦИЯ передается как аргумент в другую функцию.
    }

        // Функция 2
    function fnWithCallback(callbackFunction) {
callbackFunction()
// Вызывает ТУ ФУНКЦИЮ которую положат в ПАРАМЕТР.
// В теле этой функции вызывается КОЛБЕК ФУНКЦИЯ, Функция 1.
    }

        // Вызов ФУНКЦИИ 2 И в ПАРАМЕНТР КЛАДЕМ ФУНКЦИЮ 1 !!!
    fnWithCallback(anotherFunction)
    // Вызов функции 

  // Пример

  function printMyName() {
    console.log('Vlad')
  }

  console.log('Start')

  setTimeout(printMyName, 2000) // Функция setTimeout отложенного запуска.
  // Эта функция отложенного запуска, вызывает внутри себя функцию которая передана как первый аргумент в вызове Функции setTimeout.
  // В данном примере, одна функция вызывает другую через отложенное время а именно 2 секунды.


// Колбэки и функции высшего порядка. Фундаментальный JavaScript


// Вариант номер 1

function treeSquared() {
    return 3 * 3
}
// Вернет 6

// Вариант номер 2

function numSquared(num) {
    return num * num
}

numSquared(3)
// Вернет нечто умноженное само на себя!
// Вернет 6

// Аналогичный пример но уже с МАССИВАМИ где учавствует ПЕРЕБОР for!!!

// Пример 1 умножение.

function copyArrayAndSquareNums(arr) { // В параметр arr получим МАССИВ!
    const output = []; // Создаем новый массив.

    for (let i = 0; i < arr.length; i += 1) {
     output.push(arr[i] ** 2); // Новый синтаксис ** 2 или arr[i] * arr[i]
        
    }
    // Обходим ориг массив умножаем само на себя число и в изменненый массив бросаем в новый массив output.

    return output;
    // Вернем новый output массив.
}


// Пример 2 деление.


function copyArrayAndSquareNums(arr) { 
    const output = [];

    for (let i = 0; i < arr.length; i += 1) {
     output.push(arr[i] / arr[i]);
        
    }

    return output;
    
}
// По факту в примере 1 и 2 аналогичный код за исключением отлиыия в одной строке output.push(arr[i] / arr[i])

// И тогда мы приходим к КОЛБЕК ФУНКЦИЯМ!!!


//Функции Callback!

//Функции высшего порядка это функции которые принимают в аргумент другую функции!

//Callback функции это отдельная функция которая передается в функцию высшего порядка как аргумент! (То есть как ссылка на данную функцию, функция вашего порядке будет на нее ссылаться.)

//Замыкание Функции!

//Функция вашего порядка может создать функцию внутри себя, и возвращает их через оператора return. Это уже замыкание.

const arrM = [1, 2, 3, 4, 5]

function copyArrayAndDoSmth(arr, instructions) { 
    const output = [];

    for (let i = 0; i < arr.length; i += 1) {
     output.push(instructions(arr[i]));
        
    }

    return output;
    
}

function numSquared(num) {
    return num * num
}
// КОЛБЕК ФУНКЦИЯ!

function divideBy2(num) {
    return num / num
}
// КОЛБЕК ФУНКЦИЯ!


const resFn = copyArrayAndDoSmth(arrM, numSquared)
// Вызов ФУНКЦИИ ВЫСШЕГО ПОРЯДКА с передачей МАССИВА как первый аргмент и передачей КОБЕК ФУНКЦИИ КАК ВТОРОЙ АРГУМЕНТ!

console.log(resFn)
// [ 1, 4, 9, 16, 25 ]




  //////////////////////////////  ПРАВИЛА РАБОТЫ ФУНКЦИИ !!!  //////////////////////////////

// 1) Называть функции исходя из выполняемых задач.
// Чтобы было понятно что функция делает, как и название любых переменных.

// 2) Одна функция дожна выполнять одну задачу.
// Функция которая работает с числами И отдельно функция которая работает с строками.

// 3) Не рекомендуется изменять внешние относительно функции перменные.
// Если функция работает с обьектами, то внутри функции содаем копию таких обьектов и меняем их,
// не меняя при этом оригинальные обьекты которые были переданы как значение аргументов.
// То есть функция должна быть чистой, функция работает только с перменными которые обьявлены внутри самой функции И ОНА НЕ МЕНЯЕТ ВНЕШНИЕ ПЕРЕМЕННЫЕ!!!
// ДАЖЕ ТЕ КОТОРЫЕ ПЕРЕДАНЫ КАК АРГУМЕНТ ЭТОЙ ФУНКЦИИ.

// Если в функции нету return то функция возвращает undefined.


//////////////////////////////  ЗАМЫКАНЕИ ФУНКЦИИ !!!  //////////////////////////////

// Замыкание в JavaScript

// 1. Функция в качесиве своей работы возвоащает новые функции.
// По сути функция генерирует новую функцию внутри себя и возвращает наружу.

// 2) Возвращаемые функции помнят контекст, где были созданы.





 //////////////////////////////  ОБДАСТЬ ВИДИМОСТИ !!!  //////////////////////////////

 // Область видимости определяет границы действия переменной.

 // 1) ЕСТЬ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ которые обьявлены в ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.
 // 2) ЕСТЬ ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ которые обьявлены в ЛОКАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.

// Пример 1

 let z // Создали глобальные переменные на одному ряду с глобальным обьектом window!
 let x // Создали глобальные переменные на одному ряду с глобальным обьектом window!

 function myFn() { // Глобальная область видимлсти видит myFn.
    let x // Обявлена локальная переменная! Доступна только {внутри скобок функции}
    z = true
    x = 10
    console.log(x) // 10
 }

 // При вызове функции в теле функции, между скобками создвется {локальная область видимлсти}


 myFn()

 console.log(z) // true
 // Внутри  функции присвоили  z = true, так как внутри функции нету перменной z, присвоили выше по коду к глобальной перменной z.
 console.log(x) // undefine
// Вывод рузультата обращения к глобальной переменной X

// Итог 

// 10
// true
// undefined

// Пример 2

const o = 5

function myFn() {
    function innerFn() {
        console.log(o) // 5
    }
    innerFn()
}

myFn()

// console.log(o) // 5
// Резутьтат вызова функции myFn() undefined
// Функция не имеет ключевого слова return поэтому возврат вызова myFn() будет undefined.

// 1) Создали в глобальной области видимости переменную o.
// 2) Создали в глобальной области видимости функцию myFn.
// 3) При вызове функции myFn создается внутри нее функция innerFn().
// 4) Вызываем в облвсти видимости функии myFn функцию innerFn().
// 5) В локальной области видимости innerFn() создается  console.log(o).
// 6) При вызове функции innerFn() интерпретатор js пойдет искать переменную o по коду выше.
// 7) Ищет в локальной области видимости функции innerFn(), здесь нету.
// 8) Ищет в локальной области видимости функции myFn(), и здесь нету.
// 9) Идет в глобальную облась видимости и там находит переменную const o = 5.
// 10) Выводит в консоль значение меременной const o = 5.

// ЭТО НАЗЫВАЕТСЯ ЦЕПОЧКА ОБЛАСТЕЙ ВИДИМОСТИ!





 //////////////////////////////  ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННЫХ !!!  //////////////////////////////



//  let a
//  let b
 
//  function myFn() {
//  let b
//  a = true
//  b = 10
//  console. log(b) // 10
 
//  myFn()
 
//  console. log(a) // true
//  console. log(b) // undefined

// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННОЙ b

// 1) let b обьявление переменной "b" в глобальной обоасти видимости. Ее значение undefine, так как изначально мы не присваиваем значение.
// 2) Вызов функции myFn() после чего содается локальная зона видимости в функции myFn().
// 3) let b Обьевление "b" в локальной зоне видимости функции myFn().
// 4) b = 10 Интерпретатор js ищет в рамках функции, находит let b в области видимости функции и присваивает ей значение 10.
// 5) console. log(b) // 10 Внутри функции вывод в консоль b.
// 6) Функция myFn() заканчивает свою работу. Переменная b в глобальной зоне видимости все так же undefined.
// 7) В глобальной зоне видимости выводим console. log(b) получаем undefined.
// После того как отработала функция myFn() ее переменные были удалены!!!


// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННОЙ a

// 1) let a обьявление переменной "a" в глобальной обоасти видимости. Ее значение undefine, так как изначально мы не присваиваем значение.
// 2) Вызов функции myFn() после чего содается локальная зона видимости в функции myFn().
// 3) Обьвлена ли "a" в зоне видимости функции? НЕТ и нет параметра с таким именем. Обьвлена ли "a" в внешней области видимости? ДА. Присваиваем значение a = true.
// Итог изнутри ЧТО НЕ РЕКОМЕНДУЕТСЯ функции присвоили значение true вглобальную переменную a. До присвеяния у переменной a было значение undefined.
// Функция myFn() заканчивает свою работу. Все локальные переменные функции myFn() удалились.
// 4) В глобальной зоне видимости выводим console. log(a) // true

// НЕ РЕКОМЕНДУЕТСЯ ИЗНУТРИ ФУНКЦИИ МЕНЯТЬ ЗНАЧЕНИЕ ВНЕШНИХ ПЕРЕМЕННЫХ!!!
// Чтобы избежать этого, нам нужно обьявлять новые переменные внутри функции, как сделанно с переменной b.
// В этом вся разница глобальной зоной видимости и локальной!

// ПЕРЕМЕННАЯ В ЛОКАЛЬНЫЙ ЗОНЕ ВИДИМОСТИ ВСЕГДА ИМЕЕТ ПРИОРИТЕТ!!!
// То есть интерпретатор JS начнет посик переменной именно с локальной зоны видимости ПОСЛЕ ЧЕГО ПОЙДЕТ ВВЕРХ ПО КОДУ!





 //////////////////////////////  ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ !!!  //////////////////////////////

 // 1) Глобальная облась видимости.
 // 2) Область видимости функции.
 // 3) Облась видимости БЛОКА.

 // Переменные, обьявленные с помощью let и const внутри блока имеют область видимости, ограниченную этим блоком.

 // Блок это все что находится {между скобками}

 if (5 > 2) {
    console.log('Hello') // То есть console.log('Hello') находится внутри блока!
 }

 // Пример как делать НЕ НУЖНО!!!

 function myFn() {
    a = true // Ищем переменную a в локальной зоне видимости или выше по коду, не находим. После чего создается атоматически переменна a.
    // Причем такая переменная "a" будет создана в ГЛОБАЛЬНОЙ области видимости!!!
    console.log(a) // true
 }

 myFn()

 console.log(a) // true
 // Обращение в ГЛОБАЛЬНОЙ области видимости к переменной "a".
 // true это то значение которое было присвоено внутри функции переменной "a" псле чего атоматически было создано В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.
// Когда в итоге мы не нашли не где такой переменной!

// ТАК ДЕЛАТЬ КРАЙНЕ НЕ РЕКОМЕНДУЕТСЯ!!!!!!!

// НЕ РЕКОМЕНДУЕТСЯ приставивать внутри ФУНКЦИИ какй-то значение переменным которые ранее не были обьявлены.


 //////////////////////////////  ПРАВИЛА РАБОТЫ С ПЕРЕМЕННЫМИ !!!  //////////////////////////////

 // 1) Все переменные обьявлять перед их использованием! (Чтобы автоматически не содавались переменные)
 // 2) Старасться использовать const везде где это вохможно!
 // 3) Внутри функции не изменять переменные с внешних областей видимости.

// Чтобы соблюдать данные правила, нужно внутри функции объявлять те переменные которые нам нужны в рамках функции.

// Параметры функции это своего рода переменные, которые получают значениие в момент вызова функции!

// СТРОГИЙ РЕЖИМ !!!

 //////////////////////////////  СТРОГИЙ РЕЖИМ !!!  //////////////////////////////

 'use strict' // Это инструкция JS более пристально наблюдать за переменными и не только.
 // Достаточно добавить первой строкой в любой код, допустим еад функцией которая что-то делает.

 function myFn() {
    a = true 
    console.log(a)
 }

 myFn()

 console.log(a)

 // В данном примере интерпретатор JS ищет переменную вверх по коду, он ее не найдет, и вместо того чтобы создать переменную "a" автоматически ОН ВЫДАСТ ОШИБКУ!


  //////////////////////////////  ОПЕРАТОРЫ !!!  //////////////////////////////

// Арифметические
//   + плюс      - минус       * умножить      / разделить


// Сравнения
// === равно      !== неравно       меньше либо равно <=      больше либо равно >=


// Логичесике операторы
// ! "НЕ"       && "И"      || "ИЛИ"


// Оператор Присваивания равно  =


// ТЕКТОВЫЕ ОПЕРАТОРЫ

// typeof - можно проерсить того или иного значения.
// instanceof - можно проверить принадлежность обьекта тому или иному кдассу.
// new - Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов.
// delete - можно удвлить свойство в обьекте.


// Есть еще оператор запятая ","

let test, test1 // Создаст 2 переменные в глоабальной области видимости.

test = 10
// Присваивание "=" 10
test1 = test
// Присваивание "=" test1 = test

let u = test1 + test
// Присваивание "=" выражение test + test1. И есть оператор плюс "+"
// Сначала мы получим результат test1 + test выражения и после произайдет присваивание выражения в переменную "с".

console.log(u) // 20


//////////////////////////////  ОПЕРАТОР ПРИСВАИВАНИЯ !!!  //////////////////////////////

// ОПЕРАТОР - ВСТРОЕННАЯ ФУНКЦИЯ.

// a = 10
// "a" и 10 это операнды, левый операнд и правый операнд. 

// function =(переменная, выражение) {
//     1. Получение результата выражения
//     2. Поиск переменной по имени
//     3. Присваивание результата выражения переменной
//     4. Возврат результата выражения
// }

// Это то что подкапотом у так называемой функции равно.


//////////////////////////////  УНАРНЫЕ ОПЕРАТОР !!!  //////////////////////////////


// У УНАРНЫХ ОПЕРАТОРАХ ВСЕНДА ОДИН ОПЕРАНТ ИЛИ АРГЕМЕНТ.

// "a++" такой оператор увеличивает значение переменной на еденицу 1.
// "a+" можно конвентировать строку в число.
//  "delete" obj.a пусть к свойству одного обьекта.
// "typeof" a провреить на ТИП той или иной переменной.
// "new" Jbject() c помощью него можно создать екземпляр класса того или иного обьекта.


//////////////////////////////  БИНАРНЫЕ ОПЕРАТОР !!!  //////////////////////////////

// У БИНАРНЫХ ОПЕРАТОРОВ ВСЕГДА ДВА ОПЕРАТОРА ИЛИ АРГЕМЕНТА!

// Оператор присваивания и два опернда. 

// Левый операнд это название переменной и правый операнд это выражение.

// a = 5 

// a + b

// a += 5 
/// берем значение "a" увеличиваем на 5 и присваиваем результирующее значение переменной "a"

// a === b
// Сравниваем значение двух переменных "a" и "b" ("===" сравнивает как тип так и значение.)
// Если мы попробуем сравнить число 5 и строку пять. То результат будет false, так как строка 5 не ровна цифре 5.
// Если сравним мтроку 5 и строку 5 то будет true так как эти строки одинаковы.

// a && b




//////////////////////////////  ФОРМАТЫ ЗАПИСИ ОПЕРАТОРОВ !!!  //////////////////////////////

// ИНФЕКСНАЯ ЗАПИСЬ

// Оператор находится между ОПЕРАНДАМИ. Это инфексная запись.
// a = true

// a + b

// a += 5

// a || b (Оператор или)

// a > b


// ПРЕФИЕСНАЯ ЗАПИСЬ это окогда сначала пишем оператор и после переменную.
// Операнд идет за оператором.

// "++a" это префиксная запись оператора ++ (Можно и a++)

// "delete" Object.a

// "typeof" a


// ПОСТФИКСНАЯ ЗАПИСЬ это окогда сначала пишем переменную и после оператор.

// a++

// a--

// myFunction() скобки () это оператор который говрит JS вызвать определенную функцию.
// Имя функции это операнд а скобки оператор вызова функции.

// Оператор идет за операндом.


//////////////////////////////  ПРИОРИТЕТНОСТЬ ОПЕРАТОРОВ !!!  //////////////////////////////

// const a = 30

// const b = 70

// const c = 80

// const d = 40

// const e = 50

// const result = a + b * c / d - e

// 1) Умножение b * c (70 * 80 = 5600)
// 2) Результат выражения b * c мы делим / на "d" (5600 / 40 = 140)
// 3) Сложим результат с значение переменной "a" (140 + 30 = 170)
// 4) После чего отнимем значение переменной "e" (170 - 50 = 120)
// Ответ 120

//////////////////////////////////////////////////////////////////////

// Если мы хотим поменять стандартную математическую приоритетность. 
// Мы можем сгрупировать в скобки.


// const a = 30

// const b = 70

// const c = 80

// const d = 80

// const e = 50



// a + ((a * c) / (d - e))

// 30 * 80 = 2400

// 80 - 50 = 30

// 2400 / 30 = 80

// 80 + 30 = 110

// 1) Умножение "a" * "c" (30 * 80 = 2400)
// 2) "d" - "e" (80 - 50 = 30)
// 3) Рузультат (a * c) делим на результат (d - e) пример - (2400 / 30 = 80)
// 4) После чего к резутату выражения плюсуем "a" (80 + 30 = 110)
// Ответ 110

///////////////////////////////////////////////////////////////////////////////

// const a = 30

// const b = 70

// const c = 80

// const d = 80

// const e = 50

// (((a + b) * c / d) - e)

// Ответ 50


// 1) Умножение "a" + "b" (30 + 70 = 100)
// 2) рузультат выражения (a + b) * c)  * "d" (100 * 80 = 8000)
// 3) Рузультат  (8000 / 80 = 100)
// 4) Результат ((a + b) * c / d) выражения минусуем "e" (100 - 50 = 50)
// Ответ 50



//////////////////////////////  ЛОГИЧЕСКИЕ ОПЕРАТОРЫ !!!  //////////////////////////////


// ОПЕРАТОР "!" НЕ префиксный оператор, пишется перед операндом!

// Пример !name или !a
// Не имя, не переменная "a"

// И "&&" еще ОПЕРАТОР ИЛИ "||" ЭТО БИНАРНЫЕ ОПЕРАТОРЫ У НИХ 2 ОПЕРАНДА!!!
// Можно обьеденять эти 2 оператора И "&&" ИЛИ "||"

// ОПЕРАТОР И "&&""


// ОПЕРАТОР ИЛИ "||"


// ОЧЕНЬ ВАЖНО ПОНИМАТЬ ЧТО ОПЕРАТОР НЕ "!" всегда возвращает значение ТИПА boolean, НЕ ЗАВИСИМА ОТ ЗНАЧЕНИЯ ОПЕРАНДА!


// То есть оператор "!" всегда возвращает либо true либо false!!!!!!!!!!!!!

// Операторы И && и ИЛИ || ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ОДНОГО ИЗ ОПЕРАНДОВ!!!!!!!!!
// Какого операнда, зависит от значений других операндов. Будут примеры.


//////////////////////////////  ЛОЖНЫЕ ЗНАЧЕНИЯ В JS  //////////////////////////////

// Ложными значениями считаются те значения, которые при привидении к логическому типу Boolean дают false.

// Привести любое значение к типу Boolean можно путем вызова функции Boolean(0) -> false.
// Boolean(value) -> false

// Это перечень значений которые приводят к false, все же остальные значения приведут к true!!!
// false (не истина)
// 0 (ноль)
// '' (пустая строка)
// undefined (неопределенно)
// null (ноль)


//////////////////////////////  ПРАКТИКА с typeof ОПЕРАТОРОМ  //////////////////////////////

// typeof это унарный оператор и это префиксный оператор.

// typeof 10
// Ответ 'number'

// typeof "Vlad"
// 'string'

// typeof false
// 'boolean'

// Это то как можно легко определить того или иного значения!


// Пример

// typeof 10 === 'number'
// typeof в данном примере сравнивает 'number' === 'number'

// let isUndefined

// typeof isUndefined === 'undefined'
// true


//////////////////////////////  ОПЕРАТОР "!" ЧАЩЕ ВСЕГО ИСПОЛЬЗУЕТСЯ в УСЛОВНЫХ ИНСТРУКЦИЯХ  //////////////////////////////

// Это такие инфтрукции как if, if else и тд...

// Примеры с оператором НЕ "!"

!10   // false
!0   // true
!'abc'     // false
!''   // true
!true   // false
!undefined   // true

// Как инверсия!!!
!false // true

// Двойное ОТРИЦАНИЕ !!

!!10   // true
!!0 (Ложное)   // false
!!'abc'     // true
!!'' (Ложное)  // false
!!true   // true
!!undefined (Ложное)  // false

const oB = {}

!!oB // true

// С помощью оператора НЕ НЕ !! или НЕ ! любое значение можно привести в буливому!

// Ложные значения с двойным отрицанием всегда даст false на выходе.

// Если исходное значение правдиво или истино, то двойное отрицание даст нам вседа true.



//////////////////////////////  ОПЕРАТОРЫ "&&" и "||" ЯВЛЯЮТСЯ ОПЕРАТОРАМИ КОРОТКОГО ЗАМЫКАНИЯ!  //////////////////////////////

// Булевое true или false работает так.
// Логические И запинается на лжи/false и возвращает то на чем запнулось или последний опертанд.
// Логическое ИЛИ запинается на правде/true и возвращает то на чем запнулось или последний опертанд.
// Логическое НЕ !==
// Приводит опертанд к булю, если необходимо, а затем делает инверсию tru это будет false и наоборот.


// Логическое И запинается на лжи и возвращает то на чем запнулось или последний операнд. Работает до первого false, как только его встречает, он его возвращает.

// (Должно все быть true)

// Логическое ИЛИ запинается на правде И возвращает то на чем запнулось или последний опертанд. Оператор или срабатывает на первом true и его возвращает.

// (Должен быть хоть один true)





// Оператор И "&&" запинается на лжи/false и возвращает то на чем запнулось или последний опертанд.

// Выражение 1 && Выражение 2
// В примере два операнда, между ними И "&&"

// Если "выражение 1" ложно:

// 1. Выражение 2 игнорируется!!!!!!
// 2. Возвращается результат "Выражения 1" как всего выражения "Выражение 1 && Выражение 2"

// Каждый из операндов это выражение. Любое выражение возвращает значение!!!

// Оператор И "&&" ТРЕБУЕТ В РЕЗУЛЬТАТЕ ВСЕ ЗНАЧЕНИЯ true
// Чтобы результирующее значение было правдиво!


// 1) Если "Выражение 1" истено мы оцениваем "Выражение 2"
// 2) Если "Выражение 2" ложно, возвращается результат этого выражения!!!

// Пример.

// Допустим для выезда за границу нужны паспорт И страховка. Если чего-то нету будет false если все есть будет true.


// Если два Выражение 1 && Выражение 2 ИСТИНО, вернет последний опернад то есть "Выражение 2"


///////////// Оператор И "||"
// В примере два операнда, между ними ИЛИ "||"

// Выражение 1 || Выражение 2

// Если "выражение 1" истино:

// 1. Выражение 2 игнорируется!!!!!!
// 2. Возвращается результат "Выражения 1" как всего выражения "Выражение 1 && Выражение 2"

// Возможно для поездки в страну достаточно ЛИБО заграничного паспорта ЛИБО национального.
// Это как раз ИЛИ ЛИБО то ЛИБО то true.

// Если "Выражение 1" истино все это выражение вернет РЕЗУЛЬТАТ "ВЫРАЖЕНИЯ 1"!!!!!!!!



// ТРЮК С ОПЕРАТОРАМИ И "&&" и ВЫЗОВОМ ФУНКЦИИ!!!


let q = 10

q && console.log('Выполнено!')
// Как результат всего выражения мы получим undefined, так как метод log возвращает undefined.
// Кроме того мы увидим Выполнено!, так как это то что выполняется в нутри метода log.

// Переменная q это значение 10 то есть true, проверяем второе значение оно true выполняем console.log('Выполнено!').
// ТО ЕСТЬ С ПОМОЩЬЮ ЭТОЙ ПРОВЕРКИ ПО true МОЖНО ЗАПУТИТЬ ФУНКЦИЮ!!!


let i = 0

i && console.log('Выполнено!')
// Запнется на лжи и вернет 0, второе заначение даже не будет рассматриваться.

// MDN Логическое И (&&)
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_AND

// Описание
// Логическое И (&&) вычисляет операнды слева направо, возвращая сразу значение первого попавшего ложноподобного операнда; 
// если все значения истиноподобны, возвращается значение последнего операнда.

// Примеры выражений, которые могут быть преобразованы в false:

// false;
// null;
// NaN;
// 0;
// пустая строка ("", '', ``);
// undefined.


// result = '' && 'foo';  // result is assigned "" (empty string)
// result = 2 && 0;       // result is assigned 0
// result = 'foo' && 4;   // result is assigned 4


// Несмотря на то, что оператор && может использоваться с операндами, не содержащие логических значений, он всё равно останется булевым оператором, 
// поскольку его возвращаемое значение всегда можно преобразовать в булевый примитив. Чтобы явно преобразовать возвращаемое значение этого оператора 
// (или вообще любое выражение) в соответствующее значение булевого типа, используйте двойной оператор НЕ или конструктор Boolean (en-US).


// Поскольку первый операнд (ложноподобное выражение) имеет ложное значение, то следующее выражение никогда не будет вычислено. 
// Если следующее выражение содержало функцию, то она бы никогда не была вызвана. Посмотрите пример ниже:

function A() { console.log('вызвана функция A'); return false; }
function B() { console.log('вызвана функция B'); return true; }

console.log( A() && B() );
// В результате вызова функции A, в консоли будет выведено "вызвана функция A",
// а оператор && вычислится как false (функция A возвращает false), поэтому далее в консоли появится false;
// вследствие этого оператор И прекратит вычисление и проигнорирует функцию B

// Приоритет операторов
// Оператор И имеет более высокий приоритет, чем оператор ИЛИ, поэтому оператор && выполнится раньше оператора || (см. приоритет операторов).

false || true && true            // вернёт true
true && (false || false)         // вернёт false
(2 == 3) || (4 < 0) && (1 == 1)  // вернёт false


// const myFn = () => {console.log('Стрелочная функция Выполнено!')} 


// console.log(5 && myFn)



////////////////////////////// ЦЕПОЧКА ОПЕРАТОРОВ && И ||   //////////////////////////////



 // Ищем первое ЛОЖНОЕ ЗНАЧЕНИЕ.
a && b && c && d
// Если любая из переменных ложна, вернется та переменная на которой будет false, если все переменные истина, вернется последняя переменная "d" даже если "d" ложно!!!
// За паременной может быть целове выражение, функция.


 // Ищем первое ПРАВДИВОЕ ЗНАЧЕНИЕ.
a || b || c || d
// Если "a" правдиво, возвращаем "a" на остальные не смотрим.
// Есди a, b, с, ПРАВДИВО возвращаем "d" даже если оно ЛОЖНО!!!


// ВАЖНО! Операторы И "&&" и ИЛИ "||" всегда возвращают ЗНАЧЕНИЕ ОДНОГО ИЗ ОПЕРАНДОВ!!!

// Всего три логических оператора, НЕ "!"   И "&&"   ИЛИ "||"



////////////////////////////// ОПЕРАТОР РАЗДЕЛЕНИЯ ОБЬЕКТОВ НА СВОЙСТВА "..."   //////////////////////////////

// Пример 1

const buttonT = {
    width: 200,
    text: 'Buy'
}

const redButton = {
    ...buttonT,
    color: 'red'
}
// В данном примере, мы создадим обьект redButton после чего добавим свойства  width: 200, text: 'Buy' обьекта button.
console.table(redButton) // Табличка
console.log(redButton) // { width: 200, text: 'Buy', color: 'red' }


// Пример 2


// const bluButton = {
//     width: 200,
//     text: 'Buy',
//     color: 'blu'
// }

// const greenButton = {
//     color: 'green',
//     ...bluButton 
// }
// Разберет обьект на свойста и перезапишет существующее свойство color: 'green' на color: 'blu'.
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

// console.log(greenButton) // { color: 'blu', width: 200, text: 'Buy' }




const bluButton = {
    width: 200,
    text: 'Buy',
    color: 'blu'
}

const greenButton = {
    ...bluButton, 
    color: 'green'  
}
// Разберет обьект на свойста и перезапишет существующее НОВОЕ color: 'blu' на color: 'green'.
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

console.log(greenButton) // { width: 200, text: 'Buy', color: 'green' }



////////////////////////////// ОБЬЕДИНЕНИЕ ОБЬЕКТОВ С ПОМОЩЬЮ "..."   //////////////////////////////


const buttonInfo = {
    text: 'Buy'
}

const buttonStyle = {
    color: 'yellow',
    width: 200,
    height: 300
}

const button = {
...buttonInfo,
...buttonStyle
}
// Обьеденили два обьета buttonInfo и buttonStyle в button с помощью "..."
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

console.log(button)
// { text: 'Buy', color: 'yellow', width: 200, height: 300 }


// Помним что обьекты ссолочный тип, оператор ... разделяет ориг обьекты на свойства и создает новый обьекты на базе оригинальных.
// Важно, если у ориг обьектов будут вложенные обьекты, ссылки на них сохранятся!



////////////////////////////// КОНКАТЕНАЦИЯ СТРОК!   //////////////////////////////



