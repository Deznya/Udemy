'use strict' // Это инструкция JS более пристально наблюдать за переменными и не только.
 // Достаточно добавить первой строкой в любой код, допустим над функцией которая что-то делает.


// Колбэки и функции высшего порядка. Фундаментальный JavaScript
// Ссылка на ролик https://youtu.be/ab0a8ZbCNMY

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения const c = a + b
    // Функции function myFn(a, b) {}
    // Обьекты {}

//////////////////////////////  Переменные!!!  //////////////////////////////

// 1) Все переменные обьявлять перед их использованием.
// 2) Стараться использовать const везде, где это возможно.

// Имена переменных:

// 1) PascalCase // Типы и Классы
// 2) DB_PASSWORD // Значения известны до запуска приложения и не меняются.
// 3) camelCase // Все остальные переменные.

const j = 10 // Переменная j типа число.
const h = 10+ 5 // Выражение.


//////////////////////////////  Примитивные типы!!!  //////////////////////////////

// Тип string(строка)
// boolean(логический тип)
// number(число)
// null
// undefined (неопределенно)
// symbol (символ)

const g = 15 // Примитив
const k = 'Vlad' // Примитив

//////////////////////////////  Ссылочный Тип!!!  //////////////////////////////

// object(обьект)

//////////////////////////////  Обьекты!!!  //////////////////////////////


// Если какй-то свойство содержит функцию как значение, такое свойство называется метод!

// Обьект это набор свойст, имя: значение.
// Переменная в которую мы присваиваем обьект, содержит только ссылку на обьект а сам обьект находится в другом месте памяти.


// ПОРЯДОК СВОЙСТВ НЕ ИМЕЕТ ЗНАЧЕНИЯ!!!
const myCity1 = {
    city: 'New York',
    popular: true,
    country: 'USA'
} // свойсто city:  значение 'USA'

// ПОЛУЧАЕМ ДОСТУП К ОБЬЕКТУ!!!

console.log(myCity1.city) // New York
// Точечная запись
console.log(myCity1.popular) // true
// Точечная запись

//////////////////////////////  ИЗМЕНЕНИЕ ЗНАЧЕНИЙ СВОЙСТВА ОБЬЕКТА!  //////////////////////////////

const myCity ={
    city: 'New York'
}

myCity.city = 'Las Vegas'
// Изменяем в свойстве city значение 'New York' НА 'Las Vegas'.

console.log(myCity) // { city: 'Las Vegas' }


//////////////////////////////  ИЗМЕНЕНИЕ ЗНАЧЕНИЙ СВОЙСТВА ОБЬЕКТА!  //////////////////////////////

// Переменная myCity ТИПА ОБЬЕКТ.
const myCity ={
    city: 'New York'
}
// В const находится ССЫЛКА на обьект myCity, поэтому мы можем менять его свойства и значения.
// Происходит мутация данного обьекта. Нужно делать копию обьекта и мутировать КОПИЮ обьекта а не ОРИГИНАЛ!

myCity.popular = true
// Добавили с помощью точечной записи в обьект свойство popular:  значение true.

console.log(myCity)
// { city: 'New York', popular: true}

myCity.country = 'USA'
// Добавили с помощью точечной записи в обьект свойство country:  значение 'USA'.

console.log(myCity)
// { city: 'New York', popular: true, country: 'USA' }



//////////////////////////////  УДАЛЕНИЕ СВОЙСТВ ОБЬЕКТА оператор delete!  //////////////////////////////

delete myCity.country
// Удалили свойство country

console.log(myCity)


//////////////////////////////  ДОСТУП К ЗНАЧЕНИЮ СВОЙСТВА С ИСПОЛЬЗОВАНИЕМ СКОБОК []  //////////////////////////////


const myCity ={
    city: 'New York'
}

myCity['popular'] = true
// Добавили в обьектс помощью [] свойство popular:  значение true.

console.log(myCity)
// { city: 'New York', popular: true }


const countryPropertyName = 'country'
// Поместили в переменную свойство 'country' для обьекта.

myCity[countryPropertyName] = 'USA'
// Присвоили к свойству 'country' значение 'USA'
// Добавили country: 'USA' свойство хранится в переменной countryPropertyName.
// JS перед созданием свойства посмотрит в переменную countryPropertyName, после чего создаст свойство которое хранится в переменной countryPropertyName, далее присвоили значение свойства = 'USA'.
// Есди нужно создать свойство из перменной используем скобки [] в остальных случаях используем точечную запись.

console.log(myCity)
// { city: 'New York', popular: true, country: 'USA' }

// ОТЛИЧИЕ СКОБОЧНОЙ ЗАПИСИ ОТ ТОЧЕЧНОЙ, 
// В ТО ЧТО В CКОБОЧНОЙ ЗАПИСИ [] МОЖНО ИСПОЛЬЗОВАТЬ ЛЮБОЕ ВЫРАЖЕНИЕ!

// Пример 2

const myCity ={
    name: 'Vlad',
    age: 25
}

const myCountry = 'city'

console.log(myCity)
// { name: 'Vlad', age: 15 }


myCity[myCountry] = 'USA'

console.log(myCity)
// { name: 'Vlad', age: 15, city: 'USA' }


 //////////////////////////////  В JS МОГУТ БЫТЬ ВЛОЖЕННЫЕ СВОЙСТВА КОТОРЫЕ СОДЕРЖАТ ВЛОЖЕННЫЕ ОБЬЕКТЫ!  //////////////////////////////


 const myCity = {
    city: 'New York',
    info: {
        isPopular: true,
        country: 'USA'
    }
 }

 console.log(myCity.info.isPopular) // true 
// Точечная запись, переходим во вложенный обьект и выводим значение свойства isPopular.


delete myCity.info.isPopular
 // Получаем доступ в вложенный обьекта info и удаляем его с помощью оператора delete. 
 // Можно через скобочную [] запись delete myCity.info['isPopular']
 // Скобочную запись используем когда в скобках должно быть выражение, допустим название переменной.


 console.log(myCity)
 // { city: 'New York', info: { country: 'USA' } }


 //////////////////////////////  ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ ПРИ ФОРМИРОВАНИИ ОБЪЕКТА! //////////////////////////////

 const name = 'Vlad'
 const postsQty = 23
 // Используем название перменных как выражение для свойст обьекта.

 const userProfile = { 
    name: name,
    postsQty: postsQty,
    hasSignedAgreement: false
 }

// Сначала JS получит результат того или иного свойства а после этого этот результат присвоится тому или иному свойству обьекта.

// Сокращенные свойства рекомендуется размещать в начале обьекта, чтобы было ясно где переменные в которых хранятся значения.

// const userProfile = { 
//     name,
//     postsQty,
//     hasSignedAgreement: false
//  }
 
// Сокращенный формат записи когда название переменной где находится значение свойства совподвет с название свойства!

// Обычно часть значений уже известно до формирования объекта, такие значения можно поместить в переменные. Допустим переменная password где будет находится пароль.


////////////////////////////// ГЛОБАЛЬНЫЕ ОБЪЕКТЫ! //////////////////////////////


console // Браузер глобальный обьект.

window.console // Hrome глобальный обьект.

global.console // Node.JS глобальный обьект.

globalThis // Унифицированный глобальный обьект.


// СВОЙСТВО ГЛОБАЛЬНЫХ ОБЬЕКТОВ 

window.console

global.console

console.log('Hello')

window.console.log('Hello')

global.console.log('Hello')
// Одно и тоже!



//////////////////////////////  МЕТОД - СВОЙСТВО ОБЪЕКТА ЗНАЧЕНИЕ КОТОРОГО - ФУНКЦИЯ! //////////////////////////////

// Методы - свойства обьекта, которые содержат функции.

const myCity = {
    city: 'New York',
    cityGreeting: function () {
        console.log('Greetings!!!')
    }
    
}
// В данном примере cityGreeting это метод. Вот city это просто свойство так как его значение не является функцией!!!
myCity.cityGreeting()
// Вызов МЕТОДА!

// Сокращенный формат записи без : и слова function!

const myCity = {
    city: 'New York',
    cityGreeting() { // Сокращенный формат записи.
        console.log('Greetings!!!')
    }
    
}


myCity.cityGreeting()
// Вызов МЕТОДА!


////////////////////////////// ЕСЛИ СРАВНИТЬ МЕТОДЫ VS СВОЙСТВА ОБЬЕКТОВ! //////////////////////////////

// Отличия СВЙОСТВА НЕ сожержат функции как значения а МЕТОДЫ СОДЕРЖАТ!!!
// шаблон обьекта свойство: значение

myCity.city
// Доступ к свойству

myCity.cityGreeting()
// Вызов метода



////////////////////////////// JSON! //////////////////////////////


// Есть 2 метода, для конвертиртации JSON в JS обьект и наоборот JS обьект в JSON.


JSON.parse()
// Конвертирует (парсим) JASON в JS Обьект.

JSON.stringify()
// Конвертирует JS Обьект в JASON.


const post = {
    title: 'My post',
    likesQty: 5
}
// Порядок свойств не имеет значения.

console.log(post)
// { title: 'My post', likesQty: 5 }

const postStringify = JSON.stringify(post)
// Конвертирует JS Обьект в СТРОКУ JASON.

console.log(postStringify)
// Получили СТРОКУ JSON '{"title":"My post","likesQty":5}'

const postParse = JSON.parse(postStringify)
// Конвертирует СТРОКУ JASON в JS Обьект.

console.log(postParse)
// Получили ОБЬЕКТ JS { title: 'My post', likesQty: 5 }

// JSON ЭТО ФОРМАТ ПЕРЕДАЧИ ДАННЫХ В ИНТЕРНЕТЕ!!!


////////////////////////////// МУТАЦИИ В JS! //////////////////////////////


// ЗНАЧЕНИЯ ПРИМИТИВНЫХ ТИПОВ!!! ЭТО ОЧЕНЬ ВАЖНО!!! ОСНОВЫ ОСНОВ!

// Крпирование по ЗНАЧЕНИЮ!
// ЗНАЧЕНИЕ ПРИМИТИВНЫХ ТИПОВ СОХРАНЯЕТСЯ НЕПОСРЕДСТВЕННО В САМИХ ПЕРЕМЕННЫХ!

const a = 10
// Переменная a ТИПА число ПРИМИТИВ!!!!

let b = a
// Обьявили новую переменную let b И КРАИРУЕМ a В b

b = 30
// 

console.log(a)
// 10

console.log(b)
// 30

////////////////////////////// ЗНАЧЕНИЯ ССЫЛОЧНОГО ТИПА!!! //////////////////////////////

const person = {
    name: 'Bob',
    age: 21
}

person.age = 22
// Изменили в свойстве age значение С 21 НА 22.
// Мутация Обьекта. Нужно делать копию ОБЪЕКТА и после его изменять.
person.isAdult = true
// Добавили свойство isAdult: и его значение true.
// Мутация Обьекта. Нужно делать копию ОБЪЕКТА и после его изменять.

console.log(person.age) // 22
console.log(person.isAdult) // true


// МУТИРОВАНИЕ ОБЬЕКТА ЧЕРЕЗ КОПИЮ.
const person = {
    name: 'Bob',
    age: 21
}


const person2 = person
// Крпируем ССЫЛКУ на обьект в памяти.
// То есть мы не обьект person скопировали в переменную person2 а ССЫЛКУ на один обьект в памяти!!!
// Теперь мы можем менять даннй обьект как через переменную person так и person2.


person2.age = 26
// Изменили в свойстве age значение НА 26.
person2.isAdult = true
// Добавили свойство isAdult: и его значение true.

// Мутируем обьект через ССЫЛКУ, которая хранится в переменной person2.
// То есть есть 1 обьект, ССЫЛКА на него находится в двух переменных person и person2.
// ЭТО ПРОИСХОДИТ И ЗА ТОГО ЧТО МЫ КОПИРУЕМ ТОЛЬКО ССЫЛКУ НА ОБЬЕКАТ А НЕ САМ ОБЬЕКТ!!!

console.log(person.age) // 26
console.log(person.isAdult) // true

// Всегда нужно помнить что ПРИМИТИВНЫЙ ТИП КОПИРУЕТСЯ ПО ЗНАЧЕНИЮ А ССЫЛОЧНЫЙ ТИП КОПИРУЕТСЯ ПО ССЫЛКЕ!!!





////////////////////////////// КАК ИЗБЕЖАТЬ МУТАЦИИ ОБЪЕКТОВ!!! //////////////////////////////

// Что делать если мы не хотим чтобы ОБЬЕКТ МЕНЯЛСЯ когда мы создаем КОПИЮ такого ОБЬЕКТА.

// Вариант номер 1

const person = {
    name: 'Bob',
    age: 25
}

const person2 = Object.assign({}, person)
// Object это и ТИП и КЛАСС потому с большой буквы O
// С помощью метода assign можем создать КОПИЮ нового обьекта на базе старого.
// То есть не ссылку на обьект а полностью новый обьект, МЕТОД assign создат новый обьект и запишет в него свойства обьекта person.
// Где в параметрах {} новый обьект С старого person.

person2.age = 26

console.log(person2.age) // 26
console.log(person.age) // 25

// Но если у обьекта person есть вложенные обьекты ТО ССЫЛКИ НА ЭТИ ВЛОЖЕННЫЕ ОБЬЕКТЫ СОХРАНЯЮТСЯ!!!
// То есть если есть свойство значение которого ОБЬЕКТ.

// Можно использовать Object.assign() где нет вложенных обьектов.



// Вариант номер 2


const person = {
    name: 'Bob',
    age: 25
}

const person2 = {...person}
// Три точки ... оператор СПРЕД (распыление)
// Берется обьект person и разделяется на свойства, в данном примере на name и age.
// Мы разделили старый обьект на свойства с помощью СПРЕД ... и сразу собрали эти свойства в НОВЫЙ обьект!
// person2 ЭТО НОВАЯ ССЫЛКА КОТОРАЯ ССЫЛАЕТСЯ НА НОВЫЙ ОБЬЕКТ!


person2.name = 'Alice'
// Меняем свойства НОГОВО обьекта person2.

console.log(person2.name) // Выводим свойство НОВОСОДАННОГО обьекта Alice
console.log(person.name) // Выводим свойство оригинального обьекта Bob


// Здесь как и в ВАРИАНТЕ 1 если у обьекта person есть вложенные обьекты ТО ССЫЛКИ НА ЭТИ ВЛОЖЕННЫЕ ОБЬЕКТЫ СОХРАНЯЮТСЯ!!!
// То есть меняя вложенные обьекты в распыленном обьекте спредом, ОНИ ПОМЕНЯЮТСЯ И В ОРИГИНАЛЬНОМ ОБЬЕКТЕ!!!
// Ссылки вложенных обьектов сохрянятся на ОРИГИНАЛЬНЫЙ обьект.

// Спред и Object.assign() МОЖНО ИСПОЛЬЗОВАТЬ ТОЛЬКО ЕСЛИ НЕТ ВЛОЖЕННЫХ ОБЬЕКТОВ!!!


////////////////////////////// ИЗБЕЖАТЬ МУТАЦИИ ОБЪЕКТОВ на 100% использую JSON!!! //////////////////////////////


// Вариант 3


const person = {
    name: 'Bob',
    age: 25
}

const person2 = JSON.parse(JSON.stringify(person))

// 1) Конвентируем обьект person в строку JSON.stringify(person) (Код работает как матрёшка, ИЗНУТРИ НАРУЖУ.)
// 2) На результате метода JSON.stringify(person) получили строку JSON.
// 3) Переадем строку JSON как аргемент в метод JSON.parse()
// 4) С помощью метода JSON.parse() мы обратно конвентируем строку JSON в ОБЬЕКТ JS.
// Итог, происходит двойная конвертация обьекта в строку JSON и обратно строка JSON в обьект!
// Мы получим новый обьект и в этом новом обьекте мы можем менять любые свойства, даже в вложенных обьектах.
// Оригинальный Обьект с которого мы делали конвертицию затронут не будет!
// Ссылки на вложенные обьекты если такие есть, НЕ СОХРАНЯЮТСЯ!!! Получили то что хотели.

person2.name = 'Alice'

console.log(person2.name) // Alice
console.log(person.name) // Bob



////////////////////////////// ФУНКЦИИ!!! //////////////////////////////


// 1. Функции - параметр это то что в скобках функции (локальная переменная внутри функции. Допустим a и b!
//     2. Аргумент в функции это значение для параметра во время вызова функции!
//     3. Если нужно что-то найти это значит перебрать массив, это цикл for или for of, forEach, map.
//     4. Если нужна что-то сравнить это if. 
//     5. Метод это функция объекта.
//     6. Ключевое слово This если есть вызов объект точка что-то это значит что слева , пример. user.xxxxx то This будет ссылаться на объект user! This ссылается время вызова! Не в момент объявления! Если This вызывает как метод объекта, This всегда ссылается на этот объект user.xxxxx! Если This вырывается без объекта foo(); тогда будет Undefined!
    

// Функция - это блок кода котрый можно выполнять многократно.

// Пример
let l = 5
let p = 3

c = l + p
// Одинаковые блоки кода!

console.log(c) // 8

let n = 10
let m = 5

c = n + m
// Одинаковые блоки кода!

console.log(c) // 8

// Очень рекомендуется избегать повторений блоков кода!

// На помощь приходят ФУНКЦИИ!

// Вариант 1
    function sum(a, b) {
    console.log( a + b ) 
    }


sum(10, 15) // 25

sum(10, 25) // 35

// Вариант 2
    function sumA(a, b) {
       const c = a + b 
       console.log(c) 
    }

a = 8
b = 12

    sumA(a, b) // 

    // Функция может быть...

    // 1) ...именованной
    // 2) ...присвоено переменной
    // 3) ...анонимной (без имени)
    // 4) ...аргументом при вызове другой функции (Callback функции)
    // 5) ...значением свойства (метода) обьекта. (Метод это свойство обьекта значение которого функция)

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения
    // Функции
    // Обьекты



////////////////////////////// ФУНКЦИЯ - ЭТО ОБЬЕКТ!!! //////////////////////////////


function myFn(a, b) { // (a, b) параметры функции, это переменные внутри функции а значение их определяются в момент ВЫЗОВА ФУНКЦИИ myFn(10, 5)!!!
let c
a = a + 1
c = a + b
return c // Вернет результат который равен переменной С
// После инструкция return Функция прекращает дальнейшие инструкции!!!
// Если после return есть каий-то операции они не будет выполнены!!!
// Если return ТО функция возвращает результат и заканчивает свою работу.
// Если использовали return ФУНКЦИЯ ВОЗВРАЩАЕТ РЕЗУЛЬТАТ И ЗАКАНЧИВАЕТ СВОЮ РАБОТУ!!!!
}

const res = myFn(15, 5) // Это (15, 5) аргументы!

console.log(res)

console.log(myFn.name) // myFn ФУНКЦИЯ - ЭТО ОБЬЕКТ.



////////////////////////////// ФУНКЦИЯ ВОЗВРАЩАЕТ UNDEFINED ЕСЛИ НЕТ ИНСТРУКЦИИ return ВАЖНО !!! //////////////////////////////


// Если мы говорим АРГУМЕНТЫ функции имеем ввиду ВЫЗОВ ФУНКЦИИ.
// // Если мы говорим ПАРАМЕТРЫ функции имеем ввиду ОБЬВЛЕНИЕ ФУНКЦИИ.

// Резюмируя 

// 1) Обьявили функцию в результате которой создасться переменная myFn.
// 2) Ее значение будет функция!
// 3) myFn(15, 5) вызыыввем функцию и в вызове указываем 2 аргумента 15 которые присвоятся в параметр a И 5 который присвоится в параметр b  function myFn(a, b)
// Функция возвращает значение!



function myFn(a, b) { 
    a = a + 1
    c = a + b
    return c 
    }    // ЕСЛИ НЕТ ИНСТРУКЦИИ return ФУНКЦИЯ ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ТИПА UNDEFINED

    myFn(10, 3) // 14

// Что происходит внутри функции при ее вызове!

// 1) Параметрам "a" и "b" писваиваются значения 10 и 3
// 2) Обьявляется переменная "c"
// 3) Значение "a" увеличивается на 1
// 4) Сумма значений "a" и "b" присваивается "c"
// 5) Возвращает значение "c"

function myFn() {} // Самая короткая функция.

myFn() // undefined



////////////////////////////// ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ !!! //////////////////////////////

const personOne1 = {
    name: 'Bob',
    age: 21
}

function increasePersonAge(person) {
    person.age +=1
    return person
}
// Внутри ФУНКЦИИ мутация ВНЕШНЕГО обьекта. Так делать НЕ РЕКОМЕНДУЕТСЯ!!!
// В параметр функции person передаем как аргумент обьект personOne.
// После переходим в person.age где значение 21 с помощью +=1 добавлем 1 получаем 22.

increasePersonAge(personOne1)
// Вызов функции increasePersonAge с передачей как аргумент обьект  personOne.
console.log(personOne1.age)

// Мы по ссылке которая находится в переменной в ОРИГИНАЛЬНОМ ОБЬЕКТЕ поменяли значение age: 21 на age: 22.



////////////////////////////// ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МУТИРОВАТЬ ВНЕШНИЕ ОБЪЕКТЫ!!! //////////////////////////////


// То есть мы не передаем ОРИНИНАЛЬНЫЙ ОБЬЕКТ как аргумент в ФУНКЦИЮ.
// Мы можем создать копию обьекта внутри функии!




const personOne = {
    name: 'Bob',
    age: 21
}

function increasePersonAge(person) {
    const updatePerson = Object.assign({}, person) // Создали НОВЫЙ ОБЬЕКТ и присвоили в переменную updatePers ОБЬЕКТ на БАЗЕ СТАРОГО personOne.
    updatePerson.age += 1 // К новому обьекту pdatePerson в свойство age добавили значение 1 на выходе получили age: 22
    return updatePerson // Возвращаем новый ОБЬЕКТ updatePerson.
}

const updatePersonOne = increasePersonAge(personOne) // Вызов ФУНКЦИИ 
console.log(personOne.age) // 21
console.log(updatePersonOne.age) // 22

// Вывод мы передаем ОБЪЕКТ в ФУНКЦИЮ не изменяя оригинальный ОБЪЕКТ.
// Чтобы не было мутации оригинального обьекта!!! Это важно!
// На выходе personOne НЕ ИЗМЕНИТСЯ, мы будем менять КОПИЮ такого ОБЬЕКТА.

// ФУНКЦИИ НЕ ДОЛЖНЫ МЕНЯТЬ ВНЕШНИЕ ПЕРЕМЕННЫЕ ОНИ ДОЛЖНЫ РАБОТАТЬ С СВОИМИ ВНУТРЕННИМИ ПЕРЕМЕННЫМИ!!!



//////////////////////////////  КОЛБЕК ФУНКЦИИ ВАЖНО!!!  //////////////////////////////



// Колбэки и функции высшего порядка. Фундаментальный JavaScript
// Ссылка на ролик https://youtu.be/ab0a8ZbCNMY

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения const c = a + b
    // Функции function myFn(a, b) {}
    // Обьекты {}

    //Пример

    // Функция 1
    function anotherFunction() {
        // Действия... 
        // Функция которую мы положим как аргумент в параметр Функции fnWithCallback.
        // Она же КОЛБЕК ФУНКЦИЯ!!!
        // Данная КОЛБЕК ФУНКЦИЯ передается как аргумент в другую функцию.
    }

        // Функция 2
    function fnWithCallback(callbackFunction) {
callbackFunction()
// Вызывает ТУ ФУНКЦИЮ которую положат в ПАРАМЕТР.
// В теле этой функции вызывается КОЛБЕК ФУНКЦИЯ, Функция 1.
    }

        // Вызов ФУНКЦИИ 2 И в ПАРАМЕНТР КЛАДЕМ ФУНКЦИЮ 1 !!!
    fnWithCallback(anotherFunction)
    // Вызов функции 

  // Пример

  function printMyName() {
    console.log('Vlad')
  }

  console.log('Start')

  setTimeout(printMyName, 2000) // Функция setTimeout отложенного запуска.
  // Эта функция отложенного запуска, вызывает внутри себя функцию которая передана как первый аргумент в вызове Функции setTimeout.
  // В данном примере, одна функция вызывает другую через отложенное время а именно 2 секунды.


// Колбэки и функции высшего порядка. Фундаментальный JavaScript


// Вариант номер 1

function treeSquared() {
    return 3 * 3
}
// Вернет 6

// Вариант номер 2

function numSquared(num) {
    return num * num
}

numSquared(3)
// Вернет нечто умноженное само на себя!
// Вернет 6

// Аналогичный пример но уже с МАССИВАМИ где учавствует ПЕРЕБОР for!!!

// Пример 1 умножение.

function copyArrayAndSquareNums(arr) { // В параметр arr получим МАССИВ!
    const output = []; // Создаем новый массив.

    for (let i = 0; i < arr.length; i += 1) {
     output.push(arr[i] ** 2); // Новый синтаксис ** 2 или arr[i] * arr[i]
        
    }
    // Обходим ориг массив умножаем само на себя число и в изменненый массив бросаем в новый массив output.

    return output;
    // Вернем новый output массив.
}


// Пример 2 деление.


function copyArrayAndSquareNums(arr) { 
    const output = [];

    for (let i = 0; i < arr.length; i += 1) {
     output.push(arr[i] / arr[i]);
        
    }

    return output;
    
}
// По факту в примере 1 и 2 аналогичный код за исключением отлиыия в одной строке output.push(arr[i] / arr[i])

// И тогда мы приходим к КОЛБЕК ФУНКЦИЯМ!!!


//Функции Callback!

//Функции высшего порядка это функции которые принимают в аргумент другую функции!

//Callback функции это отдельная функция которая передается в функцию высшего порядка как аргумент! (То есть как ссылка на данную функцию, функция вашего порядке будет на нее ссылаться.)

//Замыкание Функции!

//Функция вашего порядка может создать функцию внутри себя, и возвращает их через оператора return. Это уже замыкание.

const arrM = [1, 2, 3, 4, 5]

function copyArrayAndDoSmth(arr, instructions) { 
    const output = [];

    for (let i = 0; i < arr.length; i += 1) {
     output.push(instructions(arr[i]));
        
    }

    return output;
    
}

function numSquared(num) {
    return num * num
}
// КОЛБЕК ФУНКЦИЯ!

function divideBy2(num) {
    return num / num
}
// КОЛБЕК ФУНКЦИЯ!


const resFn = copyArrayAndDoSmth(arrM, numSquared)
// Вызов ФУНКЦИИ ВЫСШЕГО ПОРЯДКА с передачей МАССИВА как первый аргмент и передачей КОБЕК ФУНКЦИИ КАК ВТОРОЙ АРГУМЕНТ!

console.log(resFn)
// [ 1, 4, 9, 16, 25 ]




  //////////////////////////////  ПРАВИЛА РАБОТЫ ФУНКЦИИ !!!  //////////////////////////////

// 1) Называть функции исходя из выполняемых задач.
// Чтобы было понятно что функция делает, как и название любых переменных.

// 2) Одна функция дожна выполнять одну задачу.
// Функция которая работает с числами И отдельно функция которая работает с строками.

// 3) Не рекомендуется изменять внешние относительно функции перменные.
// Если функция работает с обьектами, то внутри функции содаем копию таких обьектов и меняем их,
// не меняя при этом оригинальные обьекты которые были переданы как значение аргументов.
// То есть функция должна быть чистой, функция работает только с перменными которые обьявлены внутри самой функции И ОНА НЕ МЕНЯЕТ ВНЕШНИЕ ПЕРЕМЕННЫЕ!!!
// ДАЖЕ ТЕ КОТОРЫЕ ПЕРЕДАНЫ КАК АРГУМЕНТ ЭТОЙ ФУНКЦИИ.

// Если в функции нету return то функция возвращает undefined.


//////////////////////////////  ЗАМЫКАНЕИ ФУНКЦИИ !!!  //////////////////////////////

// Замыкание в JavaScript

// 1. Функция в качесиве своей работы возвоащает новые функции.
// По сути функция генерирует новую функцию внутри себя и возвращает наружу.

// 2) Возвращаемые функции помнят контекст, где были созданы.





 //////////////////////////////  ОБДАСТЬ ВИДИМОСТИ !!!  //////////////////////////////

 // Область видимости определяет границы действия переменной.

 // 1) ЕСТЬ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ которые обьявлены в ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.
 // 2) ЕСТЬ ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ которые обьявлены в ЛОКАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.

// Пример 1

 let z // Создали глобальные переменные на одному ряду с глобальным обьектом window!
 let x // Создали глобальные переменные на одному ряду с глобальным обьектом window!

 function myFn() { // Глобальная область видимлсти видит myFn.
    let x // Обявлена локальная переменная! Доступна только {внутри скобок функции}
    z = true
    x = 10
    console.log(x) // 10
 }

 // При вызове функции в теле функции, между скобками создвется {локальная область видимлсти}


 myFn()

 console.log(z) // true
 // Внутри  функции присвоили  z = true, так как внутри функции нету перменной z, присвоили выше по коду к глобальной перменной z.
 console.log(x) // undefine
// Вывод рузультата обращения к глобальной переменной X

// Итог 

// 10
// true
// undefined

// Пример 2

const o = 5

function myFn() {
    function innerFn() {
        console.log(o) // 5
    }
    innerFn()
}

myFn()

// console.log(o) // 5
// Резутьтат вызова функции myFn() undefined
// Функция не имеет ключевого слова return поэтому возврат вызова myFn() будет undefined.

// 1) Создали в глобальной области видимости переменную o.
// 2) Создали в глобальной области видимости функцию myFn.
// 3) При вызове функции myFn создается внутри нее функция innerFn().
// 4) Вызываем в облвсти видимости функии myFn функцию innerFn().
// 5) В локальной области видимости innerFn() создается  console.log(o).
// 6) При вызове функции innerFn() интерпретатор js пойдет искать переменную o по коду выше.
// 7) Ищет в локальной области видимости функции innerFn(), здесь нету.
// 8) Ищет в локальной области видимости функции myFn(), и здесь нету.
// 9) Идет в глобальную облась видимости и там находит переменную const o = 5.
// 10) Выводит в консоль значение меременной const o = 5.

// ЭТО НАЗЫВАЕТСЯ ЦЕПОЧКА ОБЛАСТЕЙ ВИДИМОСТИ!





 //////////////////////////////  ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННЫХ !!!  //////////////////////////////



//  let a
//  let b
 
//  function myFn() {
//  let b
//  a = true
//  b = 10
//  console. log(b) // 10
 
//  myFn()
 
//  console. log(a) // true
//  console. log(b) // undefined

// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННОЙ b

// 1) let b обьявление переменной "b" в глобальной обоасти видимости. Ее значение undefine, так как изначально мы не присваиваем значение.
// 2) Вызов функции myFn() после чего содается локальная зона видимости в функции myFn().
// 3) let b Обьевление "b" в локальной зоне видимости функции myFn().
// 4) b = 10 Интерпретатор js ищет в рамках функции, находит let b в области видимости функции и присваивает ей значение 10.
// 5) console. log(b) // 10 Внутри функции вывод в консоль b.
// 6) Функция myFn() заканчивает свою работу. Переменная b в глобальной зоне видимости все так же undefined.
// 7) В глобальной зоне видимости выводим console. log(b) получаем undefined.
// После того как отработала функция myFn() ее переменные были удалены!!!


// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННОЙ a

// 1) let a обьявление переменной "a" в глобальной обоасти видимости. Ее значение undefine, так как изначально мы не присваиваем значение.
// 2) Вызов функции myFn() после чего содается локальная зона видимости в функции myFn().
// 3) Обьвлена ли "a" в зоне видимости функции? НЕТ и нет параметра с таким именем. Обьвлена ли "a" в внешней области видимости? ДА. Присваиваем значение a = true.
// Итог изнутри ЧТО НЕ РЕКОМЕНДУЕТСЯ функции присвоили значение true вглобальную переменную a. До присвеяния у переменной a было значение undefined.
// Функция myFn() заканчивает свою работу. Все локальные переменные функции myFn() удалились.
// 4) В глобальной зоне видимости выводим console. log(a) // true

// НЕ РЕКОМЕНДУЕТСЯ ИЗНУТРИ ФУНКЦИИ МЕНЯТЬ ЗНАЧЕНИЕ ВНЕШНИХ ПЕРЕМЕННЫХ!!!
// Чтобы избежать этого, нам нужно обьявлять новые переменные внутри функции, как сделанно с переменной b.
// В этом вся разница глобальной зоной видимости и локальной!

// ПЕРЕМЕННАЯ В ЛОКАЛЬНЫЙ ЗОНЕ ВИДИМОСТИ ВСЕГДА ИМЕЕТ ПРИОРИТЕТ!!!
// То есть интерпретатор JS начнет посик переменной именно с локальной зоны видимости ПОСЛЕ ЧЕГО ПОЙДЕТ ВВЕРХ ПО КОДУ!





 //////////////////////////////  ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ !!!  //////////////////////////////

 // 1) Глобальная облась видимости.
 // 2) Область видимости функции.
 // 3) Облась видимости БЛОКА.

 // Переменные, обьявленные с помощью let и const внутри блока имеют область видимости, ограниченную этим блоком.

 // Блок это все что находится {между скобками}

 if (5 > 2) {
    console.log('Hello') // То есть console.log('Hello') находится внутри блока!
 }

 // Пример как делать НЕ НУЖНО!!!

 function myFn() {
    a = true // Ищем переменную a в локальной зоне видимости или выше по коду, не находим. После чего создается атоматически переменна a.
    // Причем такая переменная "a" будет создана в ГЛОБАЛЬНОЙ области видимости!!!
    console.log(a) // true
 }

 myFn()

 console.log(a) // true
 // Обращение в ГЛОБАЛЬНОЙ области видимости к переменной "a".
 // true это то значение которое было присвоено внутри функции переменной "a" псле чего атоматически было создано В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.
// Когда в итоге мы не нашли не где такой переменной!

// ТАК ДЕЛАТЬ КРАЙНЕ НЕ РЕКОМЕНДУЕТСЯ!!!!!!!

// НЕ РЕКОМЕНДУЕТСЯ приставивать внутри ФУНКЦИИ какй-то значение переменным которые ранее не были обьявлены.


 //////////////////////////////  ПРАВИЛА РАБОТЫ С ПЕРЕМЕННЫМИ !!!  //////////////////////////////

 // 1) Все переменные обьявлять перед их использованием! (Чтобы автоматически не содавались переменные)
 // 2) Старасться использовать const везде где это вохможно!
 // 3) Внутри функции не изменять переменные с внешних областей видимости.

// Чтобы соблюдать данные правила, нужно внутри функции объявлять те переменные которые нам нужны в рамках функции.

// Параметры функции это своего рода переменные, которые получают значениие в момент вызова функции!

// СТРОГИЙ РЕЖИМ !!!

 //////////////////////////////  СТРОГИЙ РЕЖИМ !!!  //////////////////////////////

 'use strict' // Это инструкция JS более пристально наблюдать за переменными и не только.
 // Достаточно добавить первой строкой в любой код, допустим еад функцией которая что-то делает.

 function myFn() {
    a = true 
    console.log(a)
 }

 myFn()

 console.log(a)

 // В данном примере интерпретатор JS ищет переменную вверх по коду, он ее не найдет, и вместо того чтобы создать переменную "a" автоматически ОН ВЫДАСТ ОШИБКУ!


  //////////////////////////////  ОПЕРАТОРЫ !!!  //////////////////////////////

// Арифметические
//   + плюс      - минус       * умножить      / разделить


// Сравнения
// === равно      !== неравно       меньше либо равно <=      больше либо равно >=


// Логичесике операторы
// ! "НЕ"       && "И"      || "ИЛИ"


// Оператор Присваивания равно  =


// ТЕКТОВЫЕ ОПЕРАТОРЫ

// typeof - можно проерсить того или иного значения.
// instanceof - можно проверить принадлежность обьекта тому или иному кдассу.
// new - Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов.
// delete - можно удвлить свойство в обьекте.


// Есть еще оператор запятая ","

let test, test1 // Создаст 2 переменные в глоабальной области видимости.

test = 10
// Присваивание "=" 10
test1 = test
// Присваивание "=" test1 = test

let u = test1 + test
// Присваивание "=" выражение test + test1. И есть оператор плюс "+"
// Сначала мы получим результат test1 + test выражения и после произайдет присваивание выражения в переменную "с".

console.log(u) // 20


//////////////////////////////  ОПЕРАТОР ПРИСВАИВАНИЯ !!!  //////////////////////////////

// ОПЕРАТОР - ВСТРОЕННАЯ ФУНКЦИЯ.

// a = 10
// "a" и 10 это операнды, левый операнд и правый операнд. 

// function =(переменная, выражение) {
//     1. Получение результата выражения
//     2. Поиск переменной по имени
//     3. Присваивание результата выражения переменной
//     4. Возврат результата выражения
// }

// Это то что подкапотом у так называемой функции равно.


//////////////////////////////  УНАРНЫЕ ОПЕРАТОР !!!  //////////////////////////////


// У УНАРНЫХ ОПЕРАТОРАХ ВСЕНДА ОДИН ОПЕРАНТ ИЛИ АРГЕМЕНТ.

// "a++" такой оператор увеличивает значение переменной на еденицу 1.
// "a+" можно конвентировать строку в число.
//  "delete" obj.a пусть к свойству одного обьекта.
// "typeof" a провреить на ТИП той или иной переменной.
// "new" Jbject() c помощью него можно создать екземпляр класса того или иного обьекта.


//////////////////////////////  БИНАРНЫЕ ОПЕРАТОР !!!  //////////////////////////////

// У БИНАРНЫХ ОПЕРАТОРОВ ВСЕГДА ДВА ОПЕРАТОРА ИЛИ АРГЕМЕНТА!

// Оператор присваивания и два опернда. 

// Левый операнд это название переменной и правый операнд это выражение.

// a = 5 

// a + b

// a += 5 
/// берем значение "a" увеличиваем на 5 и присваиваем результирующее значение переменной "a"

// a === b
// Сравниваем значение двух переменных "a" и "b" ("===" сравнивает как тип так и значение.)
// Если мы попробуем сравнить число 5 и строку пять. То результат будет false, так как строка 5 не ровна цифре 5.
// Если сравним мтроку 5 и строку 5 то будет true так как эти строки одинаковы.

// a && b




//////////////////////////////  ФОРМАТЫ ЗАПИСИ ОПЕРАТОРОВ !!!  //////////////////////////////

// ИНФЕКСНАЯ ЗАПИСЬ

// Оператор находится между ОПЕРАНДАМИ. Это инфексная запись.
// a = true

// a + b

// a += 5

// a || b (Оператор или)

// a > b


// ПРЕФИЕСНАЯ ЗАПИСЬ это окогда сначала пишем оператор и после переменную.
// Операнд идет за оператором.

// "++a" это префиксная запись оператора ++ (Можно и a++)

// "delete" Object.a

// "typeof" a


// ПОСТФИКСНАЯ ЗАПИСЬ это окогда сначала пишем переменную и после оператор.

// a++

// a--

// myFunction() скобки () это оператор который говрит JS вызвать определенную функцию.
// Имя функции это операнд а скобки оператор вызова функции.

// Оператор идет за операндом.


//////////////////////////////  ПРИОРИТЕТНОСТЬ ОПЕРАТОРОВ !!!  //////////////////////////////

// const a = 30

// const b = 70

// const c = 80

// const d = 40

// const e = 50

// const result = a + b * c / d - e

// 1) Умножение b * c (70 * 80 = 5600)
// 2) Результат выражения b * c мы делим / на "d" (5600 / 40 = 140)
// 3) Сложим результат с значение переменной "a" (140 + 30 = 170)
// 4) После чего отнимем значение переменной "e" (170 - 50 = 120)
// Ответ 120

//////////////////////////////////////////////////////////////////////

// Если мы хотим поменять стандартную математическую приоритетность. 
// Мы можем сгрупировать в скобки.


// const a = 30

// const b = 70

// const c = 80

// const d = 80

// const e = 50



// a + ((a * c) / (d - e))

// 30 * 80 = 2400

// 80 - 50 = 30

// 2400 / 30 = 80

// 80 + 30 = 110

// 1) Умножение "a" * "c" (30 * 80 = 2400)
// 2) "d" - "e" (80 - 50 = 30)
// 3) Рузультат (a * c) делим на результат (d - e) пример - (2400 / 30 = 80)
// 4) После чего к резутату выражения плюсуем "a" (80 + 30 = 110)
// Ответ 110

///////////////////////////////////////////////////////////////////////////////

// const a = 30

// const b = 70

// const c = 80

// const d = 80

// const e = 50

// (((a + b) * c / d) - e)

// Ответ 50


// 1) Умножение "a" + "b" (30 + 70 = 100)
// 2) рузультат выражения (a + b) * c)  * "d" (100 * 80 = 8000)
// 3) Рузультат  (8000 / 80 = 100)
// 4) Результат ((a + b) * c / d) выражения минусуем "e" (100 - 50 = 50)
// Ответ 50



//////////////////////////////  ЛОГИЧЕСКИЕ ОПЕРАТОРЫ !!!  //////////////////////////////


// ОПЕРАТОР "!" НЕ префиксный оператор, пишется перед операндом!

// Пример !name или !a
// Не имя, не переменная "a"

// И "&&" еще ОПЕРАТОР ИЛИ "||" ЭТО БИНАРНЫЕ ОПЕРАТОРЫ У НИХ 2 ОПЕРАНДА!!!
// Можно обьеденять эти 2 оператора И "&&" ИЛИ "||"

// ОПЕРАТОР И "&&""


// ОПЕРАТОР ИЛИ "||"


// ОЧЕНЬ ВАЖНО ПОНИМАТЬ ЧТО ОПЕРАТОР НЕ "!" всегда возвращает значение ТИПА boolean, НЕ ЗАВИСИМА ОТ ЗНАЧЕНИЯ ОПЕРАНДА!


// То есть оператор "!" всегда возвращает либо true либо false!!!!!!!!!!!!!

// Операторы И && и ИЛИ || ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ОДНОГО ИЗ ОПЕРАНДОВ!!!!!!!!!
// Какого операнда, зависит от значений других операндов. Будут примеры.


//////////////////////////////  ЛОЖНЫЕ ЗНАЧЕНИЯ В JS  //////////////////////////////

// Ложными значениями считаются те значения, которые при привидении к логическому типу Boolean дают false.

// Привести любое значение к типу Boolean можно путем вызова функции Boolean(0) -> false.
// Boolean(value) -> false

// Это перечень значений которые приводят к false, все же остальные значения приведут к true!!!
// false (не истина)
// 0 (ноль)
// '' (пустая строка)
// undefined (неопределенно)
// null (ноль)


//////////////////////////////  ПРАКТИКА с typeof ОПЕРАТОРОМ  //////////////////////////////

// typeof это унарный оператор и это префиксный оператор.

// typeof 10
// Ответ 'number'

// typeof "Vlad"
// 'string'

// typeof false
// 'boolean'

// Это то как можно легко определить того или иного значения!


// Пример

// typeof 10 === 'number'
// typeof в данном примере сравнивает 'number' === 'number'

// let isUndefined

// typeof isUndefined === 'undefined'
// true


//////////////////////////////  ОПЕРАТОР "!" ЧАЩЕ ВСЕГО ИСПОЛЬЗУЕТСЯ в УСЛОВНЫХ ИНСТРУКЦИЯХ  //////////////////////////////

// Это такие инфтрукции как if, if else и тд...

// Примеры с оператором НЕ "!"

!10   // false
!0   // true
!'abc'     // false
!''   // true
!true   // false
!undefined   // true

// Как инверсия!!!
!false // true

// Двойное ОТРИЦАНИЕ !!

!!10   // true
!!0 (Ложное)   // false
!!'abc'     // true
!!'' (Ложное)  // false
!!true   // true
!!undefined (Ложное)  // false

const oB = {}

!!oB // true

// С помощью оператора НЕ НЕ !! или НЕ ! любое значение можно привести в буливому!

// Ложные значения с двойным отрицанием всегда даст false на выходе.

// Если исходное значение правдиво или истино, то двойное отрицание даст нам вседа true.



//////////////////////////////  ОПЕРАТОРЫ "&&" и "||" ЯВЛЯЮТСЯ ОПЕРАТОРАМИ КОРОТКОГО ЗАМЫКАНИЯ!  //////////////////////////////

// Булевое true или false работает так.
// Логические И запинается на лжи/false и возвращает то на чем запнулось или последний опертанд.
// Логическое ИЛИ запинается на правде/true и возвращает то на чем запнулось или последний опертанд.
// Логическое НЕ !==
// Приводит опертанд к булю, если необходимо, а затем делает инверсию tru это будет false и наоборот.


// Логическое И запинается на лжи и возвращает то на чем запнулось или последний операнд. Работает до первого false, как только его встречает, он его возвращает.

// (Должно все быть true)

// Логическое ИЛИ запинается на правде И возвращает то на чем запнулось или последний опертанд. Оператор или срабатывает на первом true и его возвращает.

// (Должен быть хоть один true)

const password = 555
let enterinPassword = 898
let massage = null

if (password === enterinPassword) {
    massage = 'Пароль верный'  // Если true 
    console.log(massage)
} else {
    massage = 'Пароль НЕ верный!' // Если false
    console.log(massage)
}



// Оператор И "&&" запинается на лжи/false и возвращает то на чем запнулось или последний опертанд.

// Выражение 1 && Выражение 2
// В примере два операнда, между ними И "&&"

// Если "выражение 1" ложно:

// 1. Выражение 2 игнорируется!!!!!!
// 2. Возвращается результат "Выражения 1" как всего выражения "Выражение 1 && Выражение 2"

// Каждый из операндов это выражение. Любое выражение возвращает значение!!!

// Оператор И "&&" ТРЕБУЕТ В РЕЗУЛЬТАТЕ ВСЕ ЗНАЧЕНИЯ true
// Чтобы результирующее значение было правдиво!


// 1) Если "Выражение 1" истено мы оцениваем "Выражение 2"
// 2) Если "Выражение 2" ложно, возвращается результат этого выражения!!!

// Пример.

// Допустим для выезда за границу нужны паспорт И страховка. Если чего-то нету будет false если все есть будет true.


// Если два Выражение 1 && Выражение 2 ИСТИНО, вернет последний опернад то есть "Выражение 2"


///////////// Оператор И "||"
// В примере два операнда, между ними ИЛИ "||"

// Выражение 1 || Выражение 2

// Если "выражение 1" истино:

// 1. Выражение 2 игнорируется!!!!!!
// 2. Возвращается результат "Выражения 1" как всего выражения "Выражение 1 && Выражение 2"

// Возможно для поездки в страну достаточно ЛИБО заграничного паспорта ЛИБО национального.
// Это как раз ИЛИ ЛИБО то ЛИБО то true.

// Если "Выражение 1" истино все это выражение вернет РЕЗУЛЬТАТ "ВЫРАЖЕНИЯ 1"!!!!!!!!



// ТРЮК С ОПЕРАТОРАМИ И "&&" и ВЫЗОВОМ ФУНКЦИИ!!!


let q = 10

q && console.log('Выполнено!')
// Как результат всего выражения мы получим undefined, так как метод log возвращает undefined.
// Кроме того мы увидим Выполнено!, так как это то что выполняется в нутри метода log.

// Переменная q это значение 10 то есть true, проверяем второе значение оно true выполняем console.log('Выполнено!').
// ТО ЕСТЬ С ПОМОЩЬЮ ЭТОЙ ПРОВЕРКИ ПО true МОЖНО ЗАПУТИТЬ ФУНКЦИЮ!!!


let i = 0

i && console.log('Выполнено!')
// Запнется на лжи и вернет 0, второе заначение даже не будет рассматриваться.

// MDN Логическое И (&&)
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_AND

// Описание
// Логическое И (&&) вычисляет операнды слева направо, возвращая сразу значение первого попавшего ложноподобного операнда; 
// если все значения истиноподобны, возвращается значение последнего операнда.

// Примеры выражений, которые могут быть преобразованы в false:

// false;
// null;
// NaN;
// 0;
// пустая строка ("", '', ``);
// undefined.


// result = '' && 'foo';  // result is assigned "" (empty string)
// result = 2 && 0;       // result is assigned 0
// result = 'foo' && 4;   // result is assigned 4


// Несмотря на то, что оператор && может использоваться с операндами, не содержащие логических значений, он всё равно останется булевым оператором, 
// поскольку его возвращаемое значение всегда можно преобразовать в булевый примитив. Чтобы явно преобразовать возвращаемое значение этого оператора 
// (или вообще любое выражение) в соответствующее значение булевого типа, используйте двойной оператор НЕ или конструктор Boolean (en-US).


// Поскольку первый операнд (ложноподобное выражение) имеет ложное значение, то следующее выражение никогда не будет вычислено. 
// Если следующее выражение содержало функцию, то она бы никогда не была вызвана. Посмотрите пример ниже:

function A() { console.log('вызвана функция A'); return false; }
function B() { console.log('вызвана функция B'); return true; }

console.log( A() && B() );
// В результате вызова функции A, в консоли будет выведено "вызвана функция A",
// а оператор && вычислится как false (функция A возвращает false), поэтому далее в консоли появится false;
// вследствие этого оператор И прекратит вычисление и проигнорирует функцию B

// Приоритет операторов
// Оператор И имеет более высокий приоритет, чем оператор ИЛИ, поэтому оператор && выполнится раньше оператора || (см. приоритет операторов).

false || true && true            // вернёт true
true && (false || false)         // вернёт false
(2 == 3) || (4 < 0) && (1 == 1)  // вернёт false


// const myFn = () => {console.log('Стрелочная функция Выполнено!')} 


// console.log(5 && myFn)



////////////////////////////// ЦЕПОЧКА ОПЕРАТОРОВ && И ||   //////////////////////////////



 // Ищем первое ЛОЖНОЕ ЗНАЧЕНИЕ.
a && b && c && d
// Если любая из переменных ложна, вернется та переменная на которой будет false, если все переменные истина, вернется последняя переменная "d" даже если "d" ложно!!!
// За паременной может быть целове выражение, функция.


 // Ищем первое ПРАВДИВОЕ ЗНАЧЕНИЕ.
a || b || c || d
// Если "a" правдиво, возвращаем "a" на остальные не смотрим.
// Есди a, b, с, ПРАВДИВО возвращаем "d" даже если оно ЛОЖНО!!!


// ВАЖНО! Операторы И "&&" и ИЛИ "||" всегда возвращают ЗНАЧЕНИЕ ОДНОГО ИЗ ОПЕРАНДОВ!!!

// Всего три логических оператора, НЕ "!"   И "&&"   ИЛИ "||"



////////////////////////////// ОПЕРАТОР РАЗДЕЛЕНИЯ ОБЬЕКТОВ НА СВОЙСТВА "..."   //////////////////////////////

// Пример 1

const buttonT = {
    width: 200,
    text: 'Buy'
}

const redButton = {
    ...buttonT,
    color: 'red'
}
// В данном примере, мы создадим обьект redButton после чего добавим свойства  width: 200, text: 'Buy' обьекта button.
console.table(redButton) // Табличка
console.log(redButton) // { width: 200, text: 'Buy', color: 'red' }


// Пример 2


// const bluButton = {
//     width: 200,
//     text: 'Buy',
//     color: 'blu'
// }

// const greenButton = {
//     color: 'green',
//     ...bluButton 
// }
// Разберет обьект на свойста и перезапишет существующее свойство color: 'green' на color: 'blu'.
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

// console.log(greenButton) // { color: 'blu', width: 200, text: 'Buy' }




const bluButton = {
    width: 200,
    text: 'Buy',
    color: 'blu'
}

const greenButton = {
    ...bluButton, 
    color: 'green'  
}
// Разберет обьект на свойста и перезапишет существующее НОВОЕ color: 'blu' на color: 'green'.
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

console.log(greenButton) // { width: 200, text: 'Buy', color: 'green' }



//////////////////////////////   ОБЬЕДИНЕНИЕ ОБЬЕКТОВ С ПОМОЩЬЮ "..."   //////////////////////////////


const buttonInfo = {
    text: 'Buy'
}

const buttonStyle = {
    color: 'yellow',
    width: 200,
    height: 300
}

const button = {
...buttonInfo,
...buttonStyle
}
// Обьеденили два обьета buttonInfo и buttonStyle в button с помощью "..."
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

console.log(button)
// { text: 'Buy', color: 'yellow', width: 200, height: 300 }


// Помним что обьекты ссолочный тип, оператор ... разделяет ориг обьекты на свойства и создает новый обьекты на базе оригинальных.
// Важно, если у ориг обьектов будут вложенные обьекты, ссылки на них сохранятся!
// С помощью оператора "..." можно легко создавать новые обьекты на основании других оьектов.



//////////////////////////////   КОНКАТЕНАЦИЯ СТРОК!   //////////////////////////////


// 'Hello ' + 'World'
// // Внемание на пробел после слова Hello.
// // 'Hello World'

// // ПЕРЕМЕННЫЕ В КОНКАТЕНАЦИИ СТРОК

// const hello = 'Hello'
// const world = 'World'

// const greeting = hello + ' ' + world

// console.log(greeting )
// Hello World

// Это все стрый вариант КОНКАТЕНАЦИИ! На помошь приходят ШАБЛОННЫЕ СТРОКИ.



//////////////////////////////   ШАБЛОННЫЕ СТРОКИ!   //////////////////////////////

const hello = 'Hello'
const world = 'World'

const greeting = `${hello} ${world}`

console.log(greeting)
// Hello World

const myName = 'Vlad'
const myCity = 'Kiev'


const templateString = `Меня зовут ${myName} я живу в городе ${myCity}`

console.log(templateString)


10 + 'Vlad' // '10Vlad'
// Произошла конвертация числа в строку, после чего соединила '10Vlad' как строку.
// Число привелось в тип строка, после чего получилась строка'10Vlad'



//////////////////////////////   ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ!   //////////////////////////////


// ОБЬЯВЛЕННАЯ ФУНКЦИЯ VS ФУНКЦИОНАЛЬНОЕ ВЫРАЖАНИЕ.


// Пример ОБЬЯВЛЕННАЯ ФУНКЦИЯ

function myFn(a, b) {
    let c
    a = a + 1
    c = a + b
    return c
}
// Создастся переменная myFn с значением ФУНКЦИЯ.

// Пример ФУНКЦИОНАЛЬНОЕ ВЫРАЖАНИЕ

// function(a, b) {
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// Сдедовательно, ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ ВСНГДА АНОНИМНЫЕ!!!

// Если в такой функции нету return тогда функция вернет undefined!

// Отличие в том что у второй функции НЕТ ИМЕНИ!!!


// ПРИСВАИВАНИЕ ФУНКЦИОАНЛЬНОГО ВЫРАЖЕНИЯ ПЕРЕМЕННОЙ!


const myFunction = function(a, b) { // Анонимное функциональное выражение.
    a = a + 1
    c = a + b
    return c
    
}

myFunction(5, 3) //9

// Мы присваиваем анонимное функциональное выражение переменной.


// ФУНКЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ В ВЫЗОВЕ ДРУГОЙ ФУНКЦИИ

// В данном случае нет смысла нашу функцию называть, потому используем аноним функцию.
setTimeout(function() {
    console.log('Отложенное сообщение')
}, 1000)
// 'Отложенное сообщение' будет выведено в консоль через 1000 мс (1 сек)

// Встроенная функция setTimeout вызовет нашу функцию через 1 сек.
// В функции setTimeout первым аргументом передается колбек функция, и вторым аргументом передается через сколько сек запцтить первый аргумент.


//////////////////////////////   СТРЕЛОЧНЫЕ ФУНКЦИИ!!!   //////////////////////////////

// СТРЕЛОЧНЫЕ ФУНКЦИИ, это функции которые имеют немного другой синтаксис и не имеют ключевого слова function!

// Пример.

// У стрелочной функции ИМЕНИ НЕТУ!!!
// Стрелочная функция сразу начинается с параметров ()!
// Функция может не иметь параметров.
// Тело функции аналогичное с бычной function.

// (a, b) => {
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// Стрелочная функция ЭТО ВЫРАЖЕНИЕ!!!
// СТРЕЛОЧНВЕ ФУНКЦИИ ВСЕГДА АНОНИМНЫЕ, и за того что у них нету имени!!!
// Они чем-то похоже на функциональное выражение, но в функциональном выражении есть ключевое слово function.


const myFunction2 = (a, b) => {
    let c
    a = a + 1
    c = a + b
    return c
}
// Имя же дать можно СТРЕЛОЧНОЙ ФУНКЦИИ, ПУТЕМ ПРИСВАИВАНИЯ К ПЕРЕМЕННОЙ!


myFunction(5, 3) // 9

// Почему же стоит делать именно таким образом, использвать функцию присвоенную к переменной.

// Когда мы используем СТРОЕЛОЧНУЮ функцию или функциональное выражение,
// мы используем const а значит не сможем случайно перезаписать функцию!!!

// ЕСЛИ МЫ ОБЬЯВЛИ ФУНКЦИЮ ЧЕРЕЗ function И ДАЕМ СРАЗУ ИМЯ ЭТОЙ ФУНКЦИИ,
// ТАКУЮ ФУНКЦИЮ МЫ МОЖЕМ СЛУЧАНОЙ ПЕРЕЗАПИСАТЬ, МЕРЕЗАПИСАВ ПЕРЕМЕННУЮ ГДЕ ХОАНИТСЯ ФУНКЦИЯ!!!


// СТРЕЛОЧНАЯ ФУНКЦИЯ В ВЫЗОВЕ ДРУГОЙ ФУНКЦИИ!


setTimeout(() => {
    console.log('Отложенное сообщение')
}, 1000)





//////////////////////////////   СОКРАЩЕНИЯ В СТРЕЛОЧНЫХ ФУНКЦИЯХ!   //////////////////////////////


// Вариант сокращения номер 1.


// Если один параметр, то круглые скобки можно опустить!!!

//  Без скобок.
_a => {
    // Тело функции
}

// С скобками.
(_a) => {
    // Тело функции
}
// Лучше добалять всегда скобки () чтобы код был более читабелен!




// Вариант сокращения номер 2.

// Фигурные скобки можно опустить, если тело функции состоит из одного выражения!
(a, b) => a + b
// ВАЖНО! В этом случае стрелочная функция НЕЯВНО ВОЗВРАЩАЕТ результат выражения!!!!!!

// То есть если есть скобки {} в стрелочной функции нужен return для возврата!!!! Если собок НЕТУ будет НЕЯВНЫЙ ВОЗВРАТ ФУГКЦИИ!!!

const myFn = (a, b) => a + b // НЕЯВНЫЙ ВОЗВРАТ!!!! return НЕ нужен.
// Эта функция сложит a + b и БЕЗ return ВЕРНЕТ результат функции.
// Если в функции одно выражение a + b то можно ее использовать! Очень удобынй вараинт!


console.log(myFn(45, 67)) // 112




//////////////////////////////   ЗНАЧЕНИЯ ПАРАМЕТРОВ ФУНКЦИЙ ПО УМОЛЧАНИЮ!   //////////////////////////////

// То есть мы можем установить значение второго аргумента если он не будет внесен при вызове функции в аргументах.

// Пример номер 1

// Дефолтная функция с ключевым словом function
function multiByFactor(value, multiplier = 1) {
    return value * multiplier
}

multiByFactor(10, 2) // 20
multiByFactor(5) //5 Здесь сработает multiplier = 1 и вместо второго аргумента, подставит число 1.



// ФУНКЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ присвоено переменной.
const multiByFactor = function(value, multiplier = 1) {
    return value * multiplier
}



// СТРЕЛОЧНАЯ ФУНКЦИЯ с дефолтными параметрами + ЯВНЫЙ ВОЗВРАТ return.
const multiByFactor = (value, multiplier = 1) => {
    return value * multiplier
}


// СТРЕЛОЧНАЯ ФУНКЦИЯ с дефолтными параметрами + НЕ ЯВНЫЙ ВОЗВРАТ БЕЗ return.
const multiByFactor = (value, multiplier = 1) => value * multiplier


// Функция написана 4-термя вариантами, если в функции одно выражение, пишем через стрелку без {} скобок!



// Не ЯВНЫЙ возвоат функции!!!
// Если одно выражение, в данном примере a * b пишем с НЕ ЯВНЫЙ возвратом.
const testFn = (a, b) => a * b

const result = testFn(4, 7)

console.log(result) // 28



// ЯВНЫЙ возврат функции!!!
// Пишем так, если в теле функции больше одного выражения!
const testFn2 = (a, b) => {
    return a * b
}

const result2 = testFn2(44, 7)

console.log(result2) // 308



////////////////////////////////////////////////////////////////////////////////////////////

// Пример номер 2 НЕ ЯВНЫЙ возврат обьекта!!!


const newPost = (post, addedAt = Date()) => ({
    ...post,
    addedAt,
})
// Сокращенный формат записи объекта!!! post: post, addedAt: addedAt.
// Совпадает название свойства обьекта и параметра функции.

const fristPost = {
    id: 1,
    author: 'Vlad'
}

// newPost(fristPost)

console.log(newPost(fristPost))

// 1. Это стрелочная функция, которая присвоена к переменной newPost.
// 2. Мы берем оригинальный обьект newPost и хотит к нему добавить свойство addedAt.
// 3. Это ствойство addedAt должно иметь значение данного поста, дату вызова функции.
// 4. У этой функции есть 2 параметра, post (ссылка на обьект) и дефолтное значение addedAt = Date().
// 5. Мы использовали Date() это вызов функции которая присвоится к свойству addedAt.
// 6. Функция Date() есть в JS по умолчанию, при вызове данной функции мы получаем текущею дату.
// 7. Новый синтаксис => ({ ...post, addedAt }) почему скобки?
// 8. Задача этой функции, вернуть новый обьект не мутируя орги обьект через оператор спред "..."
// 9. Мы хотим вернуть обьект неявно, но если мы напишем {} фигурные скобки без () JS подумает ЧТО {} ЭТО ТЕЛО ФУНКЦИИ!!!
// 10. Если мы хотим неявно вернуть обьект, мы должны такой обьект обернуть в скобки ({обьект}).
// 11. Важно, у параметра addedAt зачения будут менятся, зависимо от текущей даты!


// Шаг 1. Вызов функции newPost, передача обьекта fristPost в параметр post.
// Шаг 2. В момент вызова функции new(fristPost) происходит присваивания значания параметру addedAt.
// Шаг 3. Это значение будет сформировано исходя из текущей даты с помощью вызова функии Date().
// Шаг 4. Функция Date() вернет текущую дату, мы добавим эту дату как значение для свойства addedAt.



// Пример номер 3 ЯВНЫЙ возврат обьекта!!!

const newPost2 = (post, addedAt = Date()) => {
    return {
    ...post,
    addedAt,
    }
}



const fristPost2 = {
    id: 1,
    author: 'Vlad'
}


console.log(newPost2(fristPost2))


//////////////////////////////   ОБРАБОТКА ОШИБОК!   //////////////////////////////



const fnWithError2 = () => {
    throw new Error('Some error')
}
// Генерация ошибки в JS

fnWithError2()
// Выполнение кода остановится в момоент вызова функции!
// ЭТО БУДЕТ АНКОД ОШИБКА, НЕ ПОЙМАННАЯ ОШИБКА!

console.log('Continue...') // Этот лог уже не выполнится!
// Как только мы получаем ошибку, далее код не используется и не анализируется.


////////// Как боротся с такими ошибками?



//////// TRY/CATCH
try {
    // Выполнение блока кода.
} catch (error) {
    // Этот блок выполнется в случае возникновения ошибок в блоке try!
}
//////// TRY/CATCH

// 1. В блок try мы должны поместить блок кода в котором может быть ошибка.
// 2. Если в блоке try возникает ошибка, она попадает во второй блок catch!
// 3. И все что находится во втором блоке catch, будет выполнено.


const fnWithError = () => {
    throw new Error('Some error')
}

try {
fnWithError()
} catch (error) {
    console.error(error) // Вывод ЦЕЛОЙ ошибки в консоль. Ошибка будет присвоена как значение к переменной catch (error)
    console.log(error.massage) // Вывод только СООБЩЕНИЯ об ошибки. Some error
}
// try это ловить :) Пойманная ошибка.
// Ошибка является по сути обьектом!!! У которого будет свойство error: значение то что напишет ошибка.

console.log('Continue...')
// Если мы словили ошибку, код ниже ошибки продолжит выполнятся!
// Для чего и нужен try/catch блок.

// Очень рекомендуется, все блоки кода, где могут возникать ошибки помещать в try/catch блок.
// Чтобы поймать ошибку, ошибку можно отправить на сервер, после чего код продолжит свое выполнение.



//////////////////////////////   ИНСТРУКЦИИ!!!   //////////////////////////////


// 1. Выражение - (всегда возвращает значение.)
// 2. Интсрукции - (let a это инструкция и if () {}.)
// 3. ВЫРАЖЕНИЕ - ИНСТРУКЦИЯ.


// ВЫРАЖЕНИЕ ВСЕГДА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ!
// ФУНКЦИЯ ВСЕГДА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ИНСТРУКЦИЯ ЖЕ ВЫПОЛНЯЕТ ОПРЕДЕЛЕННЫЕ ДЕЙСТВИЯ.

// let a;
// Инструкция, обьявление переменной "a" (инструкция)
// Каждую инструкцию сделует заканчивать точка с запятой " ; "

// const b = 5;
// Вторая инструкция.

if (a > b) {
    console.log('a is larger');
}
// Инструкция if которая выполняет действия, но не требует " ; "

for (let i = 0; i+=1; i < 5) {
    console.log(i);
}
// Цикл, так же ИНСТРУКЦИЯ, но не требует " ; "

// То есть в этом примере 4 иструкции.

// То что заканчивается, {} for, if, не нужно " ; "


// ИНСТРУКЦИЯ ОБЫЧНО ЗАКАНЧТВАЕТСЯ точкой с памятой " ; "
// Это то как можно отлечить инструкцию от выражения.
// Исключение: " ; " не требуется после блока инструкции if, for.
// Точку с запятой " ; " можно опускать в JS.


//////////////////////////////   ВЫРАЖЕНИЯ МОЖЕТ БЫТЬ ИНСТРУКЦИЕЙ!!!   //////////////////////////////


// Пример

'abc'

a = a + 3;
// Это выражерние выполняется оодельно от других, если добавим " ; " будет (Выражение - Инструкция)

c = a + b;

d = 'Good' + 'Eventing';

myFunction(c, d);
//Функция всегда вернет значение, это в первую очередб выражение!!! (Выражение - Инструкция)

console.log('Hey');

// ИНСТРУКЦИЯ НЕ МОЖЕТ БЫТЬ ТРАНСФОРМИРОВАНА В ВЫРЫЖЕНИЕ!!!




// КАК ОТЛИЧАТЬ, ГДЕ ВЫРАЖЕНИЕ А ГДЕ ВЫРАЖЕНИЕ - ИНСТРУКЦИЯ?

// Как проверить???
// ВЫРАЖЕНИЯ МОГУТ БЫТЬ ИСРОЛЬЗОВАНЫ КАК АРГУМЕНТЫ В ВЫЗОВАХ ФУНКЦИЯХ! myFunction(c, d);
// СООТВЕСТВЕННО ИНСТРУКЦИИ НЕ МОГУТ БЫТЬ ИСПОЛЬЗОВАННЫ КАК АРГУМЕНТЫ В ФУНКЦИЯХ.


function myFn(a) {
    console.log(a);
}

const t = true;
let c = 10;

myFn(2 + 3) //5
myFn(t) // true
myFn(c = c + 1) // 11
myFn(c = c + 1;) // Конвентируем в ИНСТРУКЦИЮ, ИНСТРУКЦИЮ нельзя передавать как аргумент в функции!
myFn(let t) // Инструкция, нельзя передавать как аргумент в функцию!

// Выражение ВСЕГДА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ!!!

// Точка с запятой " ; " ставится после всех и нтрукций!!!
// Разные иструкции должны находится на разных строках кода!!!



//////////////////////////////   МАССИВЫ!!!   //////////////////////////////


